{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "fa3c5cbc-7dbc-4c15-9243-78c9cfe374ed",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Defaulting to user installation because normal site-packages is not writeable\n",
      "Requirement already satisfied: pip in /usr/lib/python3.12/site-packages (23.3.2)\n",
      "Collecting pip\n",
      "  Downloading pip-24.0-py3-none-any.whl.metadata (3.6 kB)\n",
      "Downloading pip-24.0-py3-none-any.whl (2.1 MB)\n",
      "\u001b[2K   \u001b[38;2;114;156;31m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m2.1/2.1 MB\u001b[0m \u001b[31m1.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0m0m\n",
      "\u001b[?25hInstalling collected packages: pip\n",
      "Successfully installed pip-24.0\n"
     ]
    }
   ],
   "source": [
    "!python -m pip install --upgrade pip"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3e99dba1-5572-4867-9b74-74a0c24059fc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Defaulting to user installation because normal site-packages is not writeable\n",
      "Collecting opencv-python\n",
      "  Downloading opencv_python-4.10.0.82-cp37-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (20 kB)\n",
      "Requirement already satisfied: numpy>=1.21.2 in /usr/lib64/python3.12/site-packages (from opencv-python) (1.26.4)\n",
      "Downloading opencv_python-4.10.0.82-cp37-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (62.5 MB)\n",
      "\u001b[2K   \u001b[38;2;114;156;31m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m62.5/62.5 MB\u001b[0m \u001b[31m7.3 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0mm eta \u001b[36m0:00:01\u001b[0m[36m0:00:01\u001b[0mm\n",
      "\u001b[?25hInstalling collected packages: opencv-python\n",
      "Successfully installed opencv-python-4.10.0.82\n"
     ]
    }
   ],
   "source": [
    "!pip install opencv-python"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6c2982f2-ac1c-41bc-88ad-cdf385d877d5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Defaulting to user installation because normal site-packages is not writeable\n",
      "Requirement already satisfied: matplotlib in /usr/lib64/python3.12/site-packages (3.8.4)\n",
      "Requirement already satisfied: contourpy>=1.0.1 in /usr/lib64/python3.12/site-packages (from matplotlib) (1.2.0)\n",
      "Requirement already satisfied: cycler>=0.10 in /usr/lib/python3.12/site-packages (from matplotlib) (0.11.0)\n",
      "Requirement already satisfied: fonttools>=4.22.0 in /usr/lib64/python3.12/site-packages (from matplotlib) (4.50.0)\n",
      "Requirement already satisfied: kiwisolver>=1.3.1 in /usr/lib64/python3.12/site-packages (from matplotlib) (1.4.5)\n",
      "Requirement already satisfied: numpy>=1.21 in /usr/lib64/python3.12/site-packages (from matplotlib) (1.26.4)\n",
      "Requirement already satisfied: packaging>=20.0 in /usr/lib/python3.12/site-packages (from matplotlib) (23.2)\n",
      "Requirement already satisfied: pillow>=8 in /usr/lib64/python3.12/site-packages (from matplotlib) (10.3.0)\n",
      "Requirement already satisfied: pyparsing>=2.3.1 in /usr/lib/python3.12/site-packages (from matplotlib) (3.1.2)\n",
      "Requirement already satisfied: python-dateutil>=2.7 in /usr/lib/python3.12/site-packages (from matplotlib) (2.8.2)\n",
      "Requirement already satisfied: six>=1.5 in /usr/lib/python3.12/site-packages (from python-dateutil>=2.7->matplotlib) (1.16.0)\n"
     ]
    }
   ],
   "source": [
    "!pip install matplotlib "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "5969aba2-ea10-4285-a1a7-1cf404731bef",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow as tf\n",
    "import os"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "dea8135c-e994-464d-87f2-b5819689a750",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[PhysicalDevice(name='/physical_device:CPU:0', device_type='CPU')]\n"
     ]
    }
   ],
   "source": [
    "gpus = tf.config.experimental.list_physical_devices(\"GPU\")\n",
    "\n",
    "for gpu in gpus:\n",
    "    tf.config.experimental.set_memory_growth(gpu, True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "29a0d68e-d71f-4e6a-aaa8-48758a0247e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "import cv2\n",
    "import imghdr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "b365ff98-3e12-4a4a-9431-0456682bd89a",
   "metadata": {},
   "outputs": [],
   "source": [
    "data_dir = \"data\"\n",
    "image_exts = [\"jpeg\", \"jpg\", \"bmp\", \"png\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "57a1322c-f9c1-4dd8-962b-edc6bd5ecadc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "05-12-21-happy-people.jpg\n",
      "10-Habits-of-Happy-People-Seniors-Today.jpg\n",
      "1000_F_42220133_toAU6USGY9jVr2XJFLssfG00cSYIJ173.jpg\n",
      "11-Habits-of-Truly-Happy-People.jpg\n",
      "154006829.jpg\n",
      "163-1635094_happiness-love-clip-art-happy-people-transparent-background.png\n",
      "170404-happy-workers-feature.jpg\n",
      "1902539.jpg\n",
      "1920px-face-smile.svg_.png.jpg\n",
      "1HEoLBLidT2u4mhJ0oiDgig.png\n",
      "20150413185238-secrets-happy-entrepreneurs-woman-gratitude-rainbow-.jpeg\n",
      "2560px-Happy_People.jpg\n",
      "3BCckliche-menschen-konzept-gruppe-von-jugendlichen-auf-der-suche-nach-unten.jpg\n",
      "56f455011e0000b300705475.jpeg\n",
      "7-Habits-of-Happy-People-image.jpeg\n",
      "7-principles-of-successful-and-happy-people.png\n",
      "71hBPTAhIXL.jpg\n",
      "7Y57w0983emdERAoQylUHIGkoEk1cIFvPkXDbeA2lVA.jpg\n",
      "8e06de1bf2171da2312b6de61c61e4bc.jpg\n",
      "960x0.jpg\n",
      "A_Sep20_14_1189155141.jpg\n",
      "Dollarphotoclub_76084977-1.jpg\n",
      "GettyImages-565706549-949x534.jpg\n",
      "GettyImages-871518740.jpg\n",
      "HAPPY-PEOPLE-CLUB-LOGO.jpg\n",
      "Happiness-Habits-10-Things-Happy-People-Do-Before-Bed-800x450.jpg\n",
      "Happy-people-800x533.jpg\n",
      "Happy-people.png\n",
      "Happy20People.jpg\n",
      "How-to-Be-Happy_1200x628-facebook.jpg\n",
      "MV5BMTM3ODM0NTQ1MF5BMl5BanBnXkFtZTcwMzAxMTM5OA._V1_.jpg\n",
      "Overtly-Cheerful-Primer-Editorials-min.png\n",
      "Screen-Shot-2012-10-23-at-12.57.22-PM.png\n",
      "Top-Secrets-of-How-to-be-Happy.jpg\n",
      "Travis-Bradberry-Happy.jpg\n",
      "Your-Words-Affect-Your-Mind-10-Things-Happy-People-Say-Every-Day.jpg\n",
      "blog_image_20180219221810890.jpg\n",
      "compassion-900x387.jpg\n",
      "crowd-of-happy-people-poster-vector-20970718.jpg\n",
      "fiendship-concept-smiling-friends-communication-weekend-university-123724503.jpg\n",
      "friends-happy-190821.jpg\n",
      "getty_107808334_121413.jpg\n",
      "getty_152414899_97046097045006_68075.jpg\n",
      "getty_476846599_970647970450014_65484.jpg\n",
      "getty_478389113_970647970450091_99776.jpg\n",
      "getty_481914813_970647970450050_86275.jpg\n",
      "getty_494581822_130796.jpg\n",
      "getty_505175324_2000131020009280246_158016.jpg\n",
      "goup-happy-people-group-jumping-isolated-white-background-35582232.jpg\n",
      "group-happy-people-isolated-over-600w-102307264.jpg\n",
      "group-of-happy-people-2.jpg\n",
      "guilherme-stecanella-375176-unsplash.jpg\n",
      "habits-of-happy-people.jpg\n",
      "habits-that-define-very-happy-people.jpg\n",
      "happiness.jpg\n",
      "happinessa.jpg\n",
      "happy-indians_5f66fd46d9f5b.jpg\n",
      "happy-people-1024x768.jpeg\n",
      "happy-people-13772392.jpg\n",
      "happy-people-14239094.jpg\n",
      "happy-people-14410042.jpg\n",
      "happy-people-6077227.jpg\n",
      "happy-people-702x336.jpg\n",
      "happy-people-group-fb.jpg\n",
      "happy-people-having-fun-over-260nw-611293913.jpg\n",
      "happy-people-vector-29209040.jpg\n",
      "happy-people-vector-839522.jpg\n",
      "happy-people.jpg\n",
      "happy-people21.jpg\n",
      "happy-people_1463241208.jpg\n",
      "happy-person.jpeg\n",
      "happy-woman-in-nature-at-sunset.jpg\n",
      "happy.jpg\n",
      "happypeople-1024x679.jpg\n",
      "hdptcar-fi-2.jpg\n",
      "how-happy-are-healthy-people.jpg\n",
      "iStock-1212931050.jpg\n",
      "jumping_for_joy_for_3_kinds_of_happy_people.jpg\n",
      "maxresdefault.jpg\n",
      "maxresdefault2.jpg\n",
      "o-HAPPY-facebook.jpg\n",
      "physed-happiness-facebookJumbo.jpg\n",
      "smile.woman_.jpg\n",
      "things-genuinely-happy-people-know.jpg\n",
      "tmp_6mv7xy_5d5b15258a507669_GettyImages-847741712.jpg\n",
      "traitshappypeople.jpg\n",
      "web3-happy-people-outside-smile-sun-nature-eduardo-dutra-620857-unsplash.jpg\n",
      "what-makes-people-happy-1024x768.jpeg\n",
      "what-makes-people-happy1.jpg\n",
      "young-and-happy-people-vector-15114154.jpg\n"
     ]
    }
   ],
   "source": [
    "for image in images:\n",
    "    print(image)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 159,
   "id": "3c1d0df2-e6db-4d31-9579-4b79f409f4e5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[109 150 189]\n",
      "  [109 150 189]\n",
      "  [107 150 189]\n",
      "  ...\n",
      "  [111 152 185]\n",
      "  [109 150 183]\n",
      "  [108 149 182]]\n",
      "\n",
      " [[110 151 190]\n",
      "  [110 151 190]\n",
      "  [108 151 190]\n",
      "  ...\n",
      "  [115 156 189]\n",
      "  [114 155 188]\n",
      "  [113 154 187]]\n",
      "\n",
      " [[110 153 192]\n",
      "  [110 153 192]\n",
      "  [110 153 192]\n",
      "  ...\n",
      "  [116 157 190]\n",
      "  [115 156 189]\n",
      "  [114 155 188]]\n",
      "\n",
      " ...\n",
      "\n",
      " [[ 14  45  76]\n",
      "  [ 10  43  76]\n",
      "  [  7  39  75]\n",
      "  ...\n",
      "  [ 64 117 174]\n",
      "  [ 60 114 174]\n",
      "  [ 59 114 171]]\n",
      "\n",
      " [[ 12  42  71]\n",
      "  [ 11  42  73]\n",
      "  [  9  39  74]\n",
      "  ...\n",
      "  [ 56 105 161]\n",
      "  [ 57 107 165]\n",
      "  [ 60 111 167]]\n",
      "\n",
      " [[  7  37  64]\n",
      "  [ 10  40  69]\n",
      "  [ 10  38  72]\n",
      "  ...\n",
      "  [ 58 105 161]\n",
      "  [ 55 104 160]\n",
      "  [ 54 103 159]]]\n",
      "<class 'numpy.ndarray'>\n"
     ]
    }
   ],
   "source": [
    "img = cv2.imread(os.path.join(\"data\", \"happy\", \"1902539.jpg\"))\n",
    "\n",
    "print(img)\n",
    "print(type(img))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 235,
   "id": "758f3fac-07d0-4cd0-9e07-8cf2c980580e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(128, 128, 3)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.image.AxesImage at 0x7fbdfd72b830>"
      ]
     },
     "execution_count": 235,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "print(img.shape)\n",
    "\n",
    "# showing an image\n",
    "# plt.imshow(img);\n",
    "\n",
    "# showing a colored image\n",
    "\n",
    "plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 221,
   "id": "02cf1510-201d-4bc0-beed-249b44e39e13",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\u001b[0;31mInit signature:\u001b[0m \u001b[0mtf\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDataset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvariant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
       "\u001b[0;31mSource:\u001b[0m        \n",
       "\u001b[0;34m@\u001b[0m\u001b[0mtf_export\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"data.Dataset\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mv1\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;32mclass\u001b[0m \u001b[0mDatasetV2\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mcollections_abc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mIterable\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mtracking_base\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTrackable\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mcomposite_tensor\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mCompositeTensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mdata_types\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDatasetV2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mmetaclass\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mabc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mABCMeta\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m\"\"\"Represents a potentially large set of elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  The `tf.data.Dataset` API supports writing descriptive and efficient input\u001b[0m\n",
       "\u001b[0;34m  pipelines. `Dataset` usage follows a common pattern:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  1. Create a source dataset from your input data.\u001b[0m\n",
       "\u001b[0;34m  2. Apply dataset transformations to preprocess the data.\u001b[0m\n",
       "\u001b[0;34m  3. Iterate over the dataset and process the elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Iteration happens in a streaming fashion, so the full dataset does not need to\u001b[0m\n",
       "\u001b[0;34m  fit into memory.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Source Datasets:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  The simplest way to create a dataset is to create it from a python `list`:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m  >>> for element in dataset:\u001b[0m\n",
       "\u001b[0;34m  ...   print(element)\u001b[0m\n",
       "\u001b[0;34m  tf.Tensor(1, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m  tf.Tensor(2, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m  tf.Tensor(3, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  To process lines from files, use `tf.data.TextLineDataset`:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  >>> dataset = tf.data.TextLineDataset([\"file1.txt\", \"file2.txt\"])\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  To process records written in the `TFRecord` format, use `TFRecordDataset`:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  >>> dataset = tf.data.TFRecordDataset([\"file1.tfrecords\", \"file2.tfrecords\"])\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  To create a dataset of all files matching a pattern, use\u001b[0m\n",
       "\u001b[0;34m  `tf.data.Dataset.list_files`:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  ```python\u001b[0m\n",
       "\u001b[0;34m  dataset = tf.data.Dataset.list_files(\"/path/*.txt\")\u001b[0m\n",
       "\u001b[0;34m  ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  See `tf.data.FixedLengthRecordDataset` and `tf.data.Dataset.from_generator`\u001b[0m\n",
       "\u001b[0;34m  for more ways to create datasets.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Transformations:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Once you have a dataset, you can apply transformations to prepare the data for\u001b[0m\n",
       "\u001b[0;34m  your model:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m  >>> dataset = dataset.map(lambda x: x*2)\u001b[0m\n",
       "\u001b[0;34m  >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m  [2, 4, 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Common Terms:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  **Element**: A single output from calling `next()` on a dataset iterator.\u001b[0m\n",
       "\u001b[0;34m    Elements may be nested structures containing multiple components. For\u001b[0m\n",
       "\u001b[0;34m    example, the element `(1, (3, \"apple\"))` has one tuple nested in another\u001b[0m\n",
       "\u001b[0;34m    tuple. The components are `1`, `3`, and `\"apple\"`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  **Component**: The leaf in the nested structure of an element.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Supported types:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  Elements can be nested structures of tuples, named tuples, and dictionaries.\u001b[0m\n",
       "\u001b[0;34m  Note that Python lists are *not* treated as nested structures of components.\u001b[0m\n",
       "\u001b[0;34m  Instead, lists are converted to tensors and treated as components. For\u001b[0m\n",
       "\u001b[0;34m  example, the element `(1, [1, 2, 3])` has only two components; the tensor `1`\u001b[0m\n",
       "\u001b[0;34m  and the tensor `[1, 2, 3]`. Element components can be of any type\u001b[0m\n",
       "\u001b[0;34m  representable by `tf.TypeSpec`, including `tf.Tensor`, `tf.data.Dataset`,\u001b[0m\n",
       "\u001b[0;34m  `tf.sparse.SparseTensor`, `tf.RaggedTensor`, and `tf.TensorArray`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  ```python\u001b[0m\n",
       "\u001b[0;34m  a = 1 # Integer element\u001b[0m\n",
       "\u001b[0;34m  b = 2.0 # Float element\u001b[0m\n",
       "\u001b[0;34m  c = (1, 2) # Tuple element with 2 components\u001b[0m\n",
       "\u001b[0;34m  d = {\"a\": (2, 2), \"b\": 3} # Dict element with 3 components\u001b[0m\n",
       "\u001b[0;34m  Point = collections.namedtuple(\"Point\", [\"x\", \"y\"])\u001b[0m\n",
       "\u001b[0;34m  e = Point(1, 2) # Named tuple\u001b[0m\n",
       "\u001b[0;34m  f = tf.data.Dataset.range(10) # Dataset element\u001b[0m\n",
       "\u001b[0;34m  ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m  For more information,\u001b[0m\n",
       "\u001b[0;34m  read [this guide](https://www.tensorflow.org/guide/data).\u001b[0m\n",
       "\u001b[0;34m  \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mvariant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a DatasetV2 object.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This is a difference between DatasetV1 and DatasetV2. DatasetV1 does not\u001b[0m\n",
       "\u001b[0;34m    take anything in its constructor whereas in the DatasetV2, we expect\u001b[0m\n",
       "\u001b[0;34m    subclasses to create a variant_tensor and pass it in to the super() call.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      variant_tensor: A DT_VARIANT tensor that represents the dataset.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor_attr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mvariant_tensor\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_graph_attr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_default_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Initialize the options for this dataset and its inputs.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moptions_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOptions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0minput_dataset\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_inputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minput_options\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdata_types\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDatasetV1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# If the V1 dataset does not have the `_dataset` attribute, we assume it\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# is a dataset source and hence does not have options. Otherwise, we\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# grab the options of `_dataset` object\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mhasattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"_dataset\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdata_types\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDatasetV2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34mEach input of dataset \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m should be a subclass of \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34m`tf.data.Dataset` but encountered \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_dataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0minput_options\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minput_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32melif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdata_types\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDatasetV2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0minput_options\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minput_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mEach input of dataset \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m should be a subclass of \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34m`tf.data.Dataset` but encountered \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_dataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0minput_options\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmerge\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_options\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_set_mutable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_variant_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor_attr\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msetter\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_variant_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The `_variant_tensor` property cannot be modified.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mdeprecation\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeprecated_args\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"Use external_state_policy instead\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                               \u001b[0;34m\"allow_stateful\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_as_serialized_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mallow_stateful\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mexternal_state_policy\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moptions_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mExternalStatePolicy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mWARN\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Produces serialized graph representation of the dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      allow_stateful: If true, we allow stateful ops to be present in the graph\u001b[0m\n",
       "\u001b[0;34m        def. In that case, the state in these ops would be thrown away.\u001b[0m\n",
       "\u001b[0;34m      strip_device_assignment: If true, non-local (i.e. job and task) device\u001b[0m\n",
       "\u001b[0;34m        assignment is stripped from ops in the serialized graph.\u001b[0m\n",
       "\u001b[0;34m      external_state_policy: The ExternalStatePolicy enum that determines how we\u001b[0m\n",
       "\u001b[0;34m        handle input pipelines that depend on external state. By default, its\u001b[0m\n",
       "\u001b[0;34m        set to WARN.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A scalar `tf.Tensor` of `tf.string` type, representing this dataset as a\u001b[0m\n",
       "\u001b[0;34m      serialized graph.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mexternal_state_policy\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpolicy\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mexternal_state_policy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_to_graph_v2\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mexternal_state_policy\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mpolicy\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_to_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mallow_stateful\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mallow_stateful\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mstrip_device_assignment\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_to_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mallow_stateful\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mallow_stateful\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_maybe_track_assets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgraph_def\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Finds and tracks nodes in `graph_def` that refer to asset files.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      graph_def: Serialized graph representation of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A dictionary mapping the node name of an asset constant to a tracked\u001b[0m\n",
       "\u001b[0;34m      `asset.Asset` object.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0masset_tracker\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0mnode\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mgraph_def\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstartswith\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"FileIdentity\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0masset_tracker\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0masset_tracker\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0mnode\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mgraph_def\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;32min\u001b[0m \u001b[0masset_tracker\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mtensor_proto\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mattr\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"value\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtensor\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mwith\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0meager_mode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdevice\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"CPU\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mnode_value\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgen_parsing_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mparse_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0mtensor_proto\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSerializeToString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstring\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0masset_tracker\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_track_trackable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0masset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mAsset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                  \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m\"_\"\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mi\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moverwrite\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mn\u001b[0m \u001b[0;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnode_value\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0masset_tracker\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_trackable_children\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                          \u001b[0msave_type\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtracking_base\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSaveType\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mCHECKPOINT\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                          \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0msave_type\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mtracking_base\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSaveType\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSAVEDMODEL\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# _trace_variant_creation only works when executing eagerly, so we don't\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# want to run it in the object initialization.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mdef_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_signature\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mautograph\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_creator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mresource\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_trace_variant_creation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mresource\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0m_creator\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_concrete_function\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# Trigger asset tracking\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mchildren\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mDatasetV2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_trackable_children\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msave_type\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mchildren\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"_variant_tracker\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_VariantTracker\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                                   \u001b[0m_creator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mchildren\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_trace_variant_creation\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Traces a function which outputs a variant `tf.Tensor` for this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note that creating this function involves evaluating an op, and is currently\u001b[0m\n",
       "\u001b[0;34m    only supported when executing eagerly.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A zero-argument `ConcreteFunction` which outputs a variant `tf.Tensor`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mvariant\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvariant\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mEagerTensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mNotImplementedError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m\"Constructing a tf.function that reproduces a given dataset is only \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m\"supported for datasets created eagerly. Please file a feature \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m\"request if this is important to you.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mwith\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0meager_mode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdevice\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"CPU\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mgraph_def\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgraph_pb2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mGraphDef\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mFromString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_as_serialized_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mexternal_state_policy\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moptions_lib\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                    \u001b[0;34m.\u001b[0m\u001b[0mExternalStatePolicy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mFAIL\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0moutput_node_names\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0mnode\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mgraph_def\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnode\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mop\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m\"_Retval\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0moutput_node_names\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minput\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutput_node_names\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mAssertionError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34mDataset graph is expected to only have one return value but found \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutput_node_names\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m return values: \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0moutput_node_names\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0moutput_node_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moutput_node_names\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mfile_path_nodes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# When building a tf.function, track files as `saved_model.Asset`s.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_default_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuilding_function\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0masset_tracker\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_maybe_track_assets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgraph_def\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfor\u001b[0m \u001b[0mkey\u001b[0m \u001b[0;32min\u001b[0m \u001b[0masset_tracker\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0massets_list\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexpand_dims\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0masset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masset_path\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mfor\u001b[0m \u001b[0masset\u001b[0m \u001b[0;32min\u001b[0m \u001b[0masset_tracker\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mfile_path_nodes\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mkey\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconcat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0massets_list\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Add functions used in this Dataset to the function's graph, since they\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# need to follow it around (and for example be added to a SavedModel which\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# references the dataset).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mvariant_function\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwrap_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction_from_graph_def\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mgraph_def\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0minputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0moutputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moutput_node_name\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m\":0\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mcaptures\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mfile_path_nodes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0mused_function\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mused_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd_to_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mvariant_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgraph\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mvariant_function\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mabc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mabstractmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_inputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a list of the input datasets of the dataset.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mraise\u001b[0m \u001b[0mNotImplementedError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m._inputs()\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_graph_attr\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0m_graph\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msetter\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The `_graph` property cannot be modified.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;31m# TODO(jsimsa): Change this to be the transitive closure of functions used\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;31m# by this dataset and its inputs.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_functions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mStructuredFunctionWrapper\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a list of functions associated with this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A list of `StructuredFunctionWrapper` objects.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns the options tensor for this dataset.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mclassmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_options_tensor_to_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcls\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mserialized_options\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Converts options tensor to tf.data.Options object.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0moptions\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moptions_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOptions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mtensor_util\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconstant_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mserialized_options\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdataset_options_pb2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mFromString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensor_util\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconstant_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mserialized_options\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_from_proto\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpb\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns the options for this dataset and its inputs.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A `tf.data.Options` object representing the dataset options.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecuting_eagerly\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_tensor_to_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_set_mutable\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mwarnings\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwarn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"To make it possible to preserve tf.data options across \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"serialization boundaries, their implementation has moved to \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"be part of the TensorFlow graph. As a consequence, the \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"options value is in general no longer known at graph \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"construction time. Invoking this method in graph mode \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"retains the legacy behavior of the original implementation, \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"but note that the returned value might not reflect the \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                  \u001b[0;34m\"actual value of the options.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_options_attr\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_apply_debug_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mdebug_mode\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDEBUG_MODE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Disable autotuning and static optimizations that could introduce\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# parallelism or asynchrony.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moptions_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOptions\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mautotune\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0menabled\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexperimental_optimization\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfilter_parallelization\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexperimental_optimization\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_and_batch_fusion\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moptions\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexperimental_optimization\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_parallelization\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_OptionsDataset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__iter__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0miterator_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOwnedIterator\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates an iterator for elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The returned iterator implements the Python Iterator protocol.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      An `tf.data.Iterator` for the elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      RuntimeError: If not inside of tf.function and not executing eagerly.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecuting_eagerly\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minside_function\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mwith\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcolocate_with\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0miterator_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOwnedIterator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"`tf.data.Dataset` only supports Python-style \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                         \u001b[0;34m\"iteration in eager mode or within tf.function.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__bool__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;32mTrue\u001b[0m  \u001b[0;31m# Required as __len__ is defined\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0m__nonzero__\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m__bool__\u001b[0m  \u001b[0;31m# Python 2 backward compatibility\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__len__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns the length of the dataset if it is known and finite.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This method requires that you are running in eager mode, and that the\u001b[0m\n",
       "\u001b[0;34m    length of the dataset is known and non-infinite. When the length may be\u001b[0m\n",
       "\u001b[0;34m    unknown or infinite, or if you are running in graph mode, use\u001b[0m\n",
       "\u001b[0;34m    `tf.data.Dataset.cardinality` instead.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      An integer representing the length of the dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      RuntimeError: If the dataset length is unknown or infinite, or if eager\u001b[0m\n",
       "\u001b[0;34m        execution is not enabled.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecuting_eagerly\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"`tf.data.Dataset` only supports `len` in eager mode. \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                      \u001b[0;34m\"Use `tf.data.Dataset.cardinality()` instead.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mlength\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcardinality\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mlength\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mINFINITE\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The dataset is infinite.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mlength\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mUNKNOWN\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The dataset length is unknown.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mlength\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mabc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mabstractproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0melement_spec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"The type specification of an element of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset.element_spec\u001b[0m\n",
       "\u001b[0;34m    TensorSpec(shape=(), dtype=tf.int32, name=None)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For more information,\u001b[0m\n",
       "\u001b[0;34m    read [this guide](https://www.tensorflow.org/guide/data#dataset_structure).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A (nested) structure of `tf.TypeSpec` objects matching the structure of an\u001b[0m\n",
       "\u001b[0;34m      element of this dataset and specifying the type of individual components.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mraise\u001b[0m \u001b[0mNotImplementedError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.element_spec()\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__repr__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mtype_\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_dataset\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mDatasetV1Adapter\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;34mf\"\u001b[0m\u001b[0;34m<\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype_\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name__\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m element_spec=\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m>\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m__debug_string__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a string showing the type of the dataset and its inputs.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This string is intended only for debugging purposes, and may change without\u001b[0m\n",
       "\u001b[0;34m    warning.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mlines\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mto_process\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m  \u001b[0;31m# Stack of (dataset, depth) pairs.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mwhile\u001b[0m \u001b[0mto_process\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdepth\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mto_process\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mlines\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"-\"\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mdepth\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mrepr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mto_process\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mextend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdepth\u001b[0m\u001b[0;34m+\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mds\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_inputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;34m\"\\n\"\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlines\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mas_numpy_iterator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns an iterator which converts all elements of the dataset to numpy.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Use `as_numpy_iterator` to inspect the content of your dataset. To see\u001b[0m\n",
       "\u001b[0;34m    element shapes and types, print dataset elements directly instead of using\u001b[0m\n",
       "\u001b[0;34m    `as_numpy_iterator`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> for element in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    tf.Tensor(1, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m    tf.Tensor(2, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m    tf.Tensor(3, shape=(), dtype=int32)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This method requires that you are running in eager mode and the dataset's\u001b[0m\n",
       "\u001b[0;34m    element_spec contains only `TensorSpec` components.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> for element in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    1\u001b[0m\n",
       "\u001b[0;34m    2\u001b[0m\n",
       "\u001b[0;34m    3\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> print(list(dataset.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `as_numpy_iterator()` will preserve the nested structure of dataset\u001b[0m\n",
       "\u001b[0;34m    elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices({'a': ([1, 2], [3, 4]),\u001b[0m\n",
       "\u001b[0;34m    ...                                               'b': [5, 6]})\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator()) == [{'a': (1, 3), 'b': 5},\u001b[0m\n",
       "\u001b[0;34m    ...                                       {'a': (2, 4), 'b': 6}]\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      An iterable over the elements of the dataset, with their tensors converted\u001b[0m\n",
       "\u001b[0;34m      to numpy arrays.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      TypeError: if an element contains a non-`Tensor` value.\u001b[0m\n",
       "\u001b[0;34m      RuntimeError: if eager execution is not enabled.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mcontext\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mexecuting_eagerly\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"`tf.data.Dataset.as_numpy_iterator()` is only \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                         \u001b[0;34m\"supported in eager mode.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfor\u001b[0m \u001b[0mcomponent_spec\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m(\u001b[0m\u001b[0mtensor_spec\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTensorSpec\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mragged_tensor\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mRaggedTensorSpec\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m           \u001b[0msparse_tensor_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSparseTensorSpec\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnone_tensor\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mNoneTensorSpec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34m`tf.data.Dataset.as_numpy_iterator()` is not supported for \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mdatasets that produce values of type \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mcomponent_spec\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalue_type\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mNumpyIterator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_flat_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a list `tf.TensorShapes`s for the element tensor representation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A list `tf.TensorShapes`s for the element tensor representation.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_flat_tensor_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_flat_types\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a list `tf.DType`s for the element tensor representation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A list `tf.DType`s for the element tensor representation.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_flat_tensor_types\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_flat_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Helper for setting `output_shapes` and `output_types` attrs of an op.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Most dataset op constructors expect `output_shapes` and `output_types`\u001b[0m\n",
       "\u001b[0;34m    arguments that represent the flattened structure of an element. This helper\u001b[0m\n",
       "\u001b[0;34m    function generates these attrs as a keyword argument dictionary, allowing\u001b[0m\n",
       "\u001b[0;34m    `Dataset._variant_tensor` implementations to pass `**self._flat_structure`\u001b[0m\n",
       "\u001b[0;34m    to the op constructor.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A dictionary of keyword arguments that can be passed to a dataset op\u001b[0m\n",
       "\u001b[0;34m      constructor.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"output_shapes\"\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_shapes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"output_types\"\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_types\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_metadata\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Helper for generating dataset metadata.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mmetadata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdataset_metadata_pb2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mMetadata\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_name\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmetadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_validate_and_encode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_name\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mmetadata\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_common_args\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Helper for generating arguments that are common across most dataset ops.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Most dataset op constructors expect `output_shapes` and `output_types`\u001b[0m\n",
       "\u001b[0;34m    arguments that represent the flattened structure of an element, as well as a\u001b[0m\n",
       "\u001b[0;34m    `metadata` argument for additional metadata such as user-defined dataset\u001b[0m\n",
       "\u001b[0;34m    name. This helper function generates common attributes as a keyword argument\u001b[0m\n",
       "\u001b[0;34m    dictionary, allowing `Dataset._variant_tensor` implementations to pass\u001b[0m\n",
       "\u001b[0;34m    `**self._common_args` to the op constructor.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A dictionary of keyword arguments that can be passed to a dataset op\u001b[0m\n",
       "\u001b[0;34m      constructor.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"metadata\"\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_metadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSerializeToString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"output_shapes\"\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_shapes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"output_types\"\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_types\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0m_type_spec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mDatasetSpec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mfrom_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensors\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` with a single element, comprising the given tensors.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `from_tensors` produces a dataset containing only a single element. To slice\u001b[0m\n",
       "\u001b[0;34m    the input tensor into multiple elements, use `from_tensor_slices` instead.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensors([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([1, 2, 3], dtype=int32)]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensors(([1, 2, 3], 'A'))\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(array([1, 2, 3], dtype=int32), b'A')]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # You can use `from_tensors` to produce a dataset which repeats\u001b[0m\n",
       "\u001b[0;34m    >>> # the same example many times.\u001b[0m\n",
       "\u001b[0;34m    >>> example = tf.constant([1,2,3])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensors(example).repeat(2)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([1, 2, 3], dtype=int32), array([1, 2, 3], dtype=int32)]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note that if `tensors` contains a NumPy array, and eager execution is not\u001b[0m\n",
       "\u001b[0;34m    enabled, the values will be embedded in the graph as one or more\u001b[0m\n",
       "\u001b[0;34m    `tf.constant` operations. For large datasets (> 1 GB), this can waste\u001b[0m\n",
       "\u001b[0;34m    memory and run into byte limits of graph serialization. If `tensors`\u001b[0m\n",
       "\u001b[0;34m    contains one or more large NumPy arrays, consider the alternative described\u001b[0m\n",
       "\u001b[0;34m    in [this\u001b[0m\n",
       "\u001b[0;34m    guide](https://tensorflow.org/guide/data#consuming_numpy_arrays).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      tensors: A dataset \"element\". Supported values are documented\u001b[0m\n",
       "\u001b[0;34m        [here](https://www.tensorflow.org/guide/data#dataset_structure).\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      Dataset: A `Dataset`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# from_tensors_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mfrom_tensors_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mfrom_tensors_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_from_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensors\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mfrom_tensor_slices\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensors\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` whose elements are slices of the given tensors.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The given tensors are sliced along their first dimension. This operation\u001b[0m\n",
       "\u001b[0;34m    preserves the structure of the input tensors, removing the first dimension\u001b[0m\n",
       "\u001b[0;34m    of each tensor and using it as the dataset dimension. All input tensors\u001b[0m\n",
       "\u001b[0;34m    must have the same size in their first dimensions.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Slicing a 1D tensor produces scalar tensor elements.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Slicing a 2D tensor produces 1D tensor elements.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([[1, 2], [3, 4]])\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([1, 2], dtype=int32), array([3, 4], dtype=int32)]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Slicing a tuple of 1D tensors produces tuple elements containing\u001b[0m\n",
       "\u001b[0;34m    >>> # scalar tensors.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(([1, 2], [3, 4], [5, 6]))\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(1, 3, 5), (2, 4, 6)]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Dictionary structure is also preserved.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices({\"a\": [1, 2], \"b\": [3, 4]})\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator()) == [{'a': 1, 'b': 3},\u001b[0m\n",
       "\u001b[0;34m    ...                                       {'a': 2, 'b': 4}]\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Two tensors can be combined into one Dataset object.\u001b[0m\n",
       "\u001b[0;34m    >>> features = tf.constant([[1, 3], [2, 1], [3, 3]]) # ==> 3x2 tensor\u001b[0m\n",
       "\u001b[0;34m    >>> labels = tf.constant(['A', 'B', 'A']) # ==> 3x1 tensor\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.from_tensor_slices((features, labels))\u001b[0m\n",
       "\u001b[0;34m    >>> # Both the features and the labels tensors can be converted\u001b[0m\n",
       "\u001b[0;34m    >>> # to a Dataset object separately and combined after.\u001b[0m\n",
       "\u001b[0;34m    >>> features_dataset = Dataset.from_tensor_slices(features)\u001b[0m\n",
       "\u001b[0;34m    >>> labels_dataset = Dataset.from_tensor_slices(labels)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.zip((features_dataset, labels_dataset))\u001b[0m\n",
       "\u001b[0;34m    >>> # A batched feature and label set can be converted to a Dataset\u001b[0m\n",
       "\u001b[0;34m    >>> # in similar fashion.\u001b[0m\n",
       "\u001b[0;34m    >>> batched_features = tf.constant([[[1, 3], [2, 3]],\u001b[0m\n",
       "\u001b[0;34m    ...                                 [[2, 1], [1, 2]],\u001b[0m\n",
       "\u001b[0;34m    ...                                 [[3, 3], [3, 2]]], shape=(3, 2, 2))\u001b[0m\n",
       "\u001b[0;34m    >>> batched_labels = tf.constant([['A', 'A'],\u001b[0m\n",
       "\u001b[0;34m    ...                               ['B', 'B'],\u001b[0m\n",
       "\u001b[0;34m    ...                               ['A', 'B']], shape=(3, 2, 1))\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.from_tensor_slices((batched_features, batched_labels))\u001b[0m\n",
       "\u001b[0;34m    >>> for element in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    (array([[1, 3],\u001b[0m\n",
       "\u001b[0;34m           [2, 3]], dtype=int32), array([[b'A'],\u001b[0m\n",
       "\u001b[0;34m           [b'A']], dtype=object))\u001b[0m\n",
       "\u001b[0;34m    (array([[2, 1],\u001b[0m\n",
       "\u001b[0;34m           [1, 2]], dtype=int32), array([[b'B'],\u001b[0m\n",
       "\u001b[0;34m           [b'B']], dtype=object))\u001b[0m\n",
       "\u001b[0;34m    (array([[3, 3],\u001b[0m\n",
       "\u001b[0;34m           [3, 2]], dtype=int32), array([[b'A'],\u001b[0m\n",
       "\u001b[0;34m           [b'B']], dtype=object))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note that if `tensors` contains a NumPy array, and eager execution is not\u001b[0m\n",
       "\u001b[0;34m    enabled, the values will be embedded in the graph as one or more\u001b[0m\n",
       "\u001b[0;34m    `tf.constant` operations. For large datasets (> 1 GB), this can waste\u001b[0m\n",
       "\u001b[0;34m    memory and run into byte limits of graph serialization. If `tensors`\u001b[0m\n",
       "\u001b[0;34m    contains one or more large NumPy arrays, consider the alternative described\u001b[0m\n",
       "\u001b[0;34m    in [this guide](\u001b[0m\n",
       "\u001b[0;34m    https://tensorflow.org/guide/data#consuming_numpy_arrays).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      tensors: A dataset element, whose components have the same first\u001b[0m\n",
       "\u001b[0;34m        dimension. Supported values are documented\u001b[0m\n",
       "\u001b[0;34m        [here](https://www.tensorflow.org/guide/data#dataset_structure).\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      Dataset: A `Dataset`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# from_tensor_slices_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mfrom_tensor_slices_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mfrom_tensor_slices_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_from_tensor_slices\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtensors\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mclass\u001b[0m \u001b[0m_GeneratorState\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Stores outstanding iterators created from a Python generator.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This class keeps track of potentially multiple iterators that may have\u001b[0m\n",
       "\u001b[0;34m    been created from a generator, e.g. in the case that the dataset is\u001b[0m\n",
       "\u001b[0;34m    repeated, or nested within a parallel computation.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgenerator\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_generator\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgenerator\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_lock\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mthreading\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mLock\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_next_id\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m0\u001b[0m  \u001b[0;31m# GUARDED_BY(self._lock)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_args\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterators\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_normalize_id\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# In debug mode, iterator ids may be eagerly-generated np.arrays instead\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# of Tensors. We convert them to scalars to make them hashable.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndarray\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0miterator_id\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mitem\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0miterator_id\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mget_next_id\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mwith\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_lock\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mret\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_next_id\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_next_id\u001b[0m \u001b[0;34m+=\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_args\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mret\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# NOTE(mrry): Explicitly create an array of `np.int64` because implicit\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# casting in `py_func()` will create an array of `np.int32` on Windows,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# leading to a runtime error.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mret\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mget_iterator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0miterator_id\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_normalize_id\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterators\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mexcept\u001b[0m \u001b[0mKeyError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0miterator\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0miter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_generator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_args\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterators\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0miterator\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0miterator\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0miterator_completed\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mdel\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_iterators\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_normalize_id\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0miterator_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mdeprecation\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeprecated_args\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"Use output_signature instead\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                               \u001b[0;34m\"output_types\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"output_shapes\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mfrom_generator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mgenerator\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_types\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_shapes\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0margs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_signature\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` whose elements are generated by `generator`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: The current implementation of `Dataset.from_generator()` uses\u001b[0m\n",
       "\u001b[0;34m    `tf.numpy_function` and inherits the same constraints. In particular, it\u001b[0m\n",
       "\u001b[0;34m    requires the dataset and iterator related operations to be placed\u001b[0m\n",
       "\u001b[0;34m    on a device in the same process as the Python program that called\u001b[0m\n",
       "\u001b[0;34m    `Dataset.from_generator()`. In particular, using `from_generator` will\u001b[0m\n",
       "\u001b[0;34m    preclude the use of tf.data service for scaling out dataset processing.\u001b[0m\n",
       "\u001b[0;34m    The body of `generator` will not be serialized in a `GraphDef`, and you\u001b[0m\n",
       "\u001b[0;34m    should not use this method if you need to serialize your model and restore\u001b[0m\n",
       "\u001b[0;34m    it in a different environment.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `generator` argument must be a callable object that returns\u001b[0m\n",
       "\u001b[0;34m    an object that supports the `iter()` protocol (e.g. a generator function).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The elements generated by `generator` must be compatible with either the\u001b[0m\n",
       "\u001b[0;34m    given `output_signature` argument or with the given `output_types` and\u001b[0m\n",
       "\u001b[0;34m    (optionally) `output_shapes` arguments, whichever was specified.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The recommended way to call `from_generator` is to use the\u001b[0m\n",
       "\u001b[0;34m    `output_signature` argument. In this case the output will be assumed to\u001b[0m\n",
       "\u001b[0;34m    consist of objects with the classes, shapes and types defined by\u001b[0m\n",
       "\u001b[0;34m    `tf.TypeSpec` objects from `output_signature` argument:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> def gen():\u001b[0m\n",
       "\u001b[0;34m    ...   ragged_tensor = tf.ragged.constant([[1, 2], [3]])\u001b[0m\n",
       "\u001b[0;34m    ...   yield 42, ragged_tensor\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(\u001b[0m\n",
       "\u001b[0;34m    ...      gen,\u001b[0m\n",
       "\u001b[0;34m    ...      output_signature=(\u001b[0m\n",
       "\u001b[0;34m    ...          tf.TensorSpec(shape=(), dtype=tf.int32),\u001b[0m\n",
       "\u001b[0;34m    ...          tf.RaggedTensorSpec(shape=(2, None), dtype=tf.int32)))\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.take(1))\u001b[0m\n",
       "\u001b[0;34m    [(<tf.Tensor: shape=(), dtype=int32, numpy=42>,\u001b[0m\n",
       "\u001b[0;34m    <tf.RaggedTensor [[1, 2], [3]]>)]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    There is also a deprecated way to call `from_generator` by either with\u001b[0m\n",
       "\u001b[0;34m    `output_types` argument alone or together with `output_shapes` argument.\u001b[0m\n",
       "\u001b[0;34m    In this case the output of the function will be assumed to consist of\u001b[0m\n",
       "\u001b[0;34m    `tf.Tensor` objects with the types defined by `output_types` and with the\u001b[0m\n",
       "\u001b[0;34m    shapes which are either unknown or defined by `output_shapes`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: If `generator` depends on mutable global variables or other external\u001b[0m\n",
       "\u001b[0;34m    state, be aware that the runtime may invoke `generator` multiple times\u001b[0m\n",
       "\u001b[0;34m    (in order to support repeating the `Dataset`) and at any time\u001b[0m\n",
       "\u001b[0;34m    between the call to `Dataset.from_generator()` and the production of the\u001b[0m\n",
       "\u001b[0;34m    first element from the generator. Mutating global variables or external\u001b[0m\n",
       "\u001b[0;34m    state can cause undefined behavior, and we recommend that you explicitly\u001b[0m\n",
       "\u001b[0;34m    cache any external state in `generator` before calling\u001b[0m\n",
       "\u001b[0;34m    `Dataset.from_generator()`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: While the `output_signature` parameter makes it possible to yield\u001b[0m\n",
       "\u001b[0;34m    `Dataset` elements, the scope of `Dataset.from_generator()` should be\u001b[0m\n",
       "\u001b[0;34m    limited to logic that cannot be expressed through tf.data operations. Using\u001b[0m\n",
       "\u001b[0;34m    tf.data operations within the generator function is an anti-pattern and may\u001b[0m\n",
       "\u001b[0;34m    result in incremental memory growth.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      generator: A callable object that returns an object that supports the\u001b[0m\n",
       "\u001b[0;34m        `iter()` protocol. If `args` is not specified, `generator` must take no\u001b[0m\n",
       "\u001b[0;34m        arguments; otherwise it must take as many arguments as there are values\u001b[0m\n",
       "\u001b[0;34m        in `args`.\u001b[0m\n",
       "\u001b[0;34m      output_types: (Optional.) A (nested) structure of `tf.DType` objects\u001b[0m\n",
       "\u001b[0;34m        corresponding to each component of an element yielded by `generator`.\u001b[0m\n",
       "\u001b[0;34m      output_shapes: (Optional.) A (nested) structure of `tf.TensorShape`\u001b[0m\n",
       "\u001b[0;34m        objects corresponding to each component of an element yielded by\u001b[0m\n",
       "\u001b[0;34m        `generator`.\u001b[0m\n",
       "\u001b[0;34m      args: (Optional.) A tuple of `tf.Tensor` objects that will be evaluated\u001b[0m\n",
       "\u001b[0;34m        and passed to `generator` as NumPy-array arguments.\u001b[0m\n",
       "\u001b[0;34m      output_signature: (Optional.) A (nested) structure of `tf.TypeSpec`\u001b[0m\n",
       "\u001b[0;34m        objects corresponding to each component of an element yielded by\u001b[0m\n",
       "\u001b[0;34m        `generator`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operations used by\u001b[0m\n",
       "\u001b[0;34m        `from_generator`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      Dataset: A `Dataset`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# from_generator_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mfrom_generator_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mfrom_generator_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_from_generator\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgenerator\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moutput_types\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                             \u001b[0moutput_shapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                             \u001b[0moutput_signature\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` of a step-separated range of values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(5).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(2, 5).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(1, 5, 2).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 3]\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(1, 5, -2).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    []\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(5, 1).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    []\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(5, 1, -2).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [5, 3]\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(2, 5, output_type=tf.int32).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    >>> list(Dataset.range(1, 5, 2, output_type=tf.float32).as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1.0, 3.0]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      *args: follows the same semantics as python's range.\u001b[0m\n",
       "\u001b[0;34m        len(args) == 1 -> start = 0, stop = args[0], step = 1.\u001b[0m\n",
       "\u001b[0;34m        len(args) == 2 -> start = args[0], stop = args[1], step = 1.\u001b[0m\n",
       "\u001b[0;34m        len(args) == 3 -> start = args[0], stop = args[1], step = args[2].\u001b[0m\n",
       "\u001b[0;34m      **kwargs:\u001b[0m\n",
       "\u001b[0;34m        - output_type: Its expected dtype. (Optional, default: `tf.int64`).\u001b[0m\n",
       "\u001b[0;34m        - name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      Dataset: A `RangeDataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError: if len(args) == 0.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> range_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mrange_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mrange_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_range\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdatasets\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` by zipping together the given datasets.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This method has similar semantics to the built-in `zip()` function\u001b[0m\n",
       "\u001b[0;34m    in Python, with the main difference being that the `datasets`\u001b[0m\n",
       "\u001b[0;34m    argument can be a (nested) structure of `Dataset` objects. The supported\u001b[0m\n",
       "\u001b[0;34m    nesting mechanisms are documented\u001b[0m\n",
       "\u001b[0;34m    [here] (https://www.tensorflow.org/guide/data#dataset_structure).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # The datasets or nested structure of datasets `*args` argument\u001b[0m\n",
       "\u001b[0;34m    >>> # determines the structure of elements in the resulting dataset.\u001b[0m\n",
       "\u001b[0;34m    >>> a = tf.data.Dataset.range(1, 4)  # ==> [ 1, 2, 3 ]\u001b[0m\n",
       "\u001b[0;34m    >>> b = tf.data.Dataset.range(4, 7)  # ==> [ 4, 5, 6 ]\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.zip(a, b)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(1, 4), (2, 5), (3, 6)]\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.zip(b, a)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(4, 1), (5, 2), (6, 3)]\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> # The `datasets` argument may contain an arbitrary number of datasets.\u001b[0m\n",
       "\u001b[0;34m    >>> c = tf.data.Dataset.range(7, 13).batch(2)  # ==> [ [7, 8],\u001b[0m\n",
       "\u001b[0;34m    ...                                            #       [9, 10],\u001b[0m\n",
       "\u001b[0;34m    ...                                            #       [11, 12] ]\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.zip(a, b, c)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in ds.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    (1, 4, array([7, 8]))\u001b[0m\n",
       "\u001b[0;34m    (2, 5, array([ 9, 10]))\u001b[0m\n",
       "\u001b[0;34m    (3, 6, array([11, 12]))\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> # The number of elements in the resulting dataset is the same as\u001b[0m\n",
       "\u001b[0;34m    >>> # the size of the smallest dataset in `datasets`.\u001b[0m\n",
       "\u001b[0;34m    >>> d = tf.data.Dataset.range(13, 15)  # ==> [ 13, 14 ]\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.zip(a, d)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(1, 13), (2, 14)]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      *args: Datasets or nested structures of datasets to zip together. This\u001b[0m\n",
       "\u001b[0;34m        can't be set if `datasets` is set.\u001b[0m\n",
       "\u001b[0;34m      datasets: A (nested) structure of datasets. This can't be set if `*args`\u001b[0m\n",
       "\u001b[0;34m        is set. Note that this exists only for backwards compatibility and it is\u001b[0m\n",
       "\u001b[0;34m        preferred to use *args.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> zip_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mzip_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0margs\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mdatasets\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Must pass at least one dataset to `zip`.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0margs\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mdatasets\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Both `*args` and `datasets` cannot be set.\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdatasets\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdatasets\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0margs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mzip_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_zip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdatasets\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mconcatenate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` by concatenating the given dataset with this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> a = tf.data.Dataset.range(1, 4)  # ==> [ 1, 2, 3 ]\u001b[0m\n",
       "\u001b[0;34m    >>> b = tf.data.Dataset.range(4, 8)  # ==> [ 4, 5, 6, 7 ]\u001b[0m\n",
       "\u001b[0;34m    >>> ds = a.concatenate(b)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3, 4, 5, 6, 7]\u001b[0m\n",
       "\u001b[0;34m    >>> # The input dataset and dataset to be concatenated should have\u001b[0m\n",
       "\u001b[0;34m    >>> # compatible element specs.\u001b[0m\n",
       "\u001b[0;34m    >>> c = tf.data.Dataset.zip((a, b))\u001b[0m\n",
       "\u001b[0;34m    >>> a.concatenate(c)\u001b[0m\n",
       "\u001b[0;34m    Traceback (most recent call last):\u001b[0m\n",
       "\u001b[0;34m    TypeError: Two datasets to concatenate have different types\u001b[0m\n",
       "\u001b[0;34m    <dtype: 'int64'> and (tf.int64, tf.int64)\u001b[0m\n",
       "\u001b[0;34m    >>> d = tf.data.Dataset.from_tensor_slices([\"a\", \"b\", \"c\"])\u001b[0m\n",
       "\u001b[0;34m    >>> a.concatenate(d)\u001b[0m\n",
       "\u001b[0;34m    Traceback (most recent call last):\u001b[0m\n",
       "\u001b[0;34m    TypeError: Two datasets to concatenate have different types\u001b[0m\n",
       "\u001b[0;34m    <dtype: 'int64'> and <dtype: 'string'>\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      dataset: `Dataset` to be concatenated.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# concatenate_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mconcatenate_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mconcatenate_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_concatenate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mcounter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstart\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstep\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` that counts from `start` in steps of size `step`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Unlike `tf.data.Dataset.range`, which stops at some ending number,\u001b[0m\n",
       "\u001b[0;34m    `tf.data.Dataset.counter` produces elements indefinitely.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.experimental.Counter().take(5)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset.element_spec\u001b[0m\n",
       "\u001b[0;34m    TensorSpec(shape=(), dtype=tf.int64, name=None)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.experimental.Counter(dtype=tf.int32)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset.element_spec\u001b[0m\n",
       "\u001b[0;34m    TensorSpec(shape=(), dtype=tf.int32, name=None)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.experimental.Counter(start=2).take(5)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 3, 4, 5, 6]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.experimental.Counter(start=2, step=5).take(5)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 7, 12, 17, 22]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.experimental.Counter(start=10, step=-1).take(5)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [10, 9, 8, 7, 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      start: (Optional.) The starting value for the counter. Defaults to 0.\u001b[0m\n",
       "\u001b[0;34m      step: (Optional.) The step size for the counter. Defaults to 1.\u001b[0m\n",
       "\u001b[0;34m      dtype: (Optional.) The data type for counter elements. Defaults to\u001b[0m\n",
       "\u001b[0;34m        `tf.int64`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A `Dataset` of scalar `dtype` elements.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> counter_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mcounter_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mcounter_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_counter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstep\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mfingerprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Computes the fingerprint of this `Dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    If two datasets have the same fingerprint, it is guaranteeed that they\u001b[0m\n",
       "\u001b[0;34m    would produce identical elements as long as the content of the upstream\u001b[0m\n",
       "\u001b[0;34m    input files does not change and they produce data deterministically.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    However, two datasets producing identical values does not always mean they\u001b[0m\n",
       "\u001b[0;34m    would have the same fingerprint due to different graph constructs.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    In other words, if two datasets have different fingerprints, they could\u001b[0m\n",
       "\u001b[0;34m    still produce identical values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A scalar `tf.Tensor` of type `tf.uint64`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_fingerprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mrebatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` that rebatches the elements from this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `rebatch(N)` is functionally equivalent to `unbatch().batch(N)`, but is\u001b[0m\n",
       "\u001b[0;34m    more efficient, performing one copy instead of two.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.range(6)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.batch(2)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.rebatch(3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1, 2]), array([3, 4, 5])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.range(7)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.batch(4)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.rebatch(3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1, 2]), array([3, 4, 5]), array([6])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.range(7)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.batch(2)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.rebatch(3, drop_remainder=True)\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1, 2]), array([3, 4, 5])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    If the `batch_size` argument is a list, `rebatch` cycles through the list\u001b[0m\n",
       "\u001b[0;34m    to determine the size of each batch.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.range(8)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.batch(4)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.rebatch([2, 1, 1])\u001b[0m\n",
       "\u001b[0;34m    >>> list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1]), array([2]), array([3]), array([4, 5]), array([6]),\u001b[0m\n",
       "\u001b[0;34m    array([7])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      batch_size: A `tf.int64` scalar or vector, representing the size of\u001b[0m\n",
       "\u001b[0;34m        batches to produce. If this argument is a vector, these values are\u001b[0m\n",
       "\u001b[0;34m        cycled through in round robin fashion.\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last batch should be dropped in the case it has fewer than\u001b[0m\n",
       "\u001b[0;34m        `batch_size[cycle_index]` elements; the default behavior is not to drop\u001b[0m\n",
       "\u001b[0;34m        the smaller batch.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A `Dataset` of scalar `dtype` elements.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> rebatch_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# rebatch_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mrebatch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mrebatch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_rebatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mprefetch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` that prefetches elements from this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Most dataset input pipelines should end with a call to `prefetch`. This\u001b[0m\n",
       "\u001b[0;34m    allows later elements to be prepared while the current element is being\u001b[0m\n",
       "\u001b[0;34m    processed. This often improves latency and throughput, at the cost of\u001b[0m\n",
       "\u001b[0;34m    using additional memory to store prefetched elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: Like other `Dataset` methods, prefetch operates on the\u001b[0m\n",
       "\u001b[0;34m    elements of the input dataset. It has no concept of examples vs. batches.\u001b[0m\n",
       "\u001b[0;34m    `examples.prefetch(2)` will prefetch two elements (2 examples),\u001b[0m\n",
       "\u001b[0;34m    while `examples.batch(20).prefetch(2)` will prefetch 2 elements\u001b[0m\n",
       "\u001b[0;34m    (2 batches, of 20 examples each).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.prefetch(2)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      buffer_size: A `tf.int64` scalar `tf.Tensor`, representing the maximum\u001b[0m\n",
       "\u001b[0;34m        number of elements that will be buffered when prefetching. If the value\u001b[0m\n",
       "\u001b[0;34m        `tf.data.AUTOTUNE` is used, then the buffer size is dynamically tuned.\u001b[0m\n",
       "\u001b[0;34m      name: Optional. A name for the tf.data transformation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mprefetch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_prefetch\u001b[0m\u001b[0;34m(\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mlist_files\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mfile_pattern\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mshuffle\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"A dataset of all files matching one or more glob patterns.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `file_pattern` argument should be a small number of glob patterns.\u001b[0m\n",
       "\u001b[0;34m    If your filenames have already been globbed, use\u001b[0m\n",
       "\u001b[0;34m    `Dataset.from_tensor_slices(filenames)` instead, as re-globbing every\u001b[0m\n",
       "\u001b[0;34m    filename with `list_files` may result in poor performance with remote\u001b[0m\n",
       "\u001b[0;34m    storage systems.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: The default behavior of this method is to return filenames in\u001b[0m\n",
       "\u001b[0;34m    a non-deterministic random shuffled order. Pass a `seed` or `shuffle=False`\u001b[0m\n",
       "\u001b[0;34m    to get results in a deterministic order.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Example:\u001b[0m\n",
       "\u001b[0;34m      If we had the following files on our filesystem:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m        - /path/to/dir/a.txt\u001b[0m\n",
       "\u001b[0;34m        - /path/to/dir/b.py\u001b[0m\n",
       "\u001b[0;34m        - /path/to/dir/c.py\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      If we pass \"/path/to/dir/*.py\" as the directory, the dataset\u001b[0m\n",
       "\u001b[0;34m      would produce:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m        - /path/to/dir/b.py\u001b[0m\n",
       "\u001b[0;34m        - /path/to/dir/c.py\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      file_pattern: A string, a list of strings, or a `tf.Tensor` of string type\u001b[0m\n",
       "\u001b[0;34m        (scalar or vector), representing the filename glob (i.e. shell wildcard)\u001b[0m\n",
       "\u001b[0;34m        pattern(s) that will be matched.\u001b[0m\n",
       "\u001b[0;34m      shuffle: (Optional.) If `True`, the file names will be shuffled randomly.\u001b[0m\n",
       "\u001b[0;34m        Defaults to `True`.\u001b[0m\n",
       "\u001b[0;34m      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\u001b[0m\n",
       "\u001b[0;34m        seed that will be used to create the distribution. See\u001b[0m\n",
       "\u001b[0;34m        `tf.random.set_seed` for behavior.\u001b[0m\n",
       "\u001b[0;34m      name: Optional. A name for the tf.data operations used by `list_files`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m     Dataset: A `Dataset` of strings corresponding to file names.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mwith\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname_scope\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"list_files\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mshuffle\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mshuffle\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mfile_pattern\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvert_to_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mfile_pattern\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mstring\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"file_pattern\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmatching_files\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgen_io_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmatching_files\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_pattern\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Raise an exception if `file_pattern` does not match any files.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mcondition\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgreater\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmatching_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                   \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"match_not_empty\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmessage\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m\"No files matched pattern: \"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstring_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreduce_join\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile_pattern\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseparator\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\", \"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"message\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0massert_not_empty\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcontrol_flow_assert\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mAssert\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mcondition\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msummarize\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"assert_not_empty\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mwith\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcontrol_dependencies\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0massert_not_empty\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mmatching_files\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0midentity\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmatching_files\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# TODO(b/240947712): Remove lazy import after this method is factored out.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# from_tensor_slices_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mfrom_tensor_slices_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfrom_tensor_slices_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_TensorSliceDataset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mmatching_files\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mis_files\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0missubclass\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mDataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mDatasetV1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDatasetV1Adapter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mshuffle\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# NOTE(mrry): The shuffle buffer size must be greater than zero, but the\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# list of files might be empty.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mbuffer_size\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmaximum\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmatching_files\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_type\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshuffle\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbuffer_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mseed\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mrepeat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Repeats this dataset so each original value is seen `count` times.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.repeat(3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3, 1, 2, 3, 1, 2, 3]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: If the input dataset depends on global state (e.g. a random number\u001b[0m\n",
       "\u001b[0;34m    generator) or its output is non-deterministic (e.g. because of upstream\u001b[0m\n",
       "\u001b[0;34m    `shuffle`), then different repetitions may produce different elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      count: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\u001b[0m\n",
       "\u001b[0;34m        number of times the dataset should be repeated. The default behavior (if\u001b[0m\n",
       "\u001b[0;34m        `count` is `None` or `-1`) is for the dataset be repeated indefinitely.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> repeat_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access,redefined-outer-name\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mrepeat_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mrepeat_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_repeat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access,redefined-outer-name\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0menumerate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstart\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Enumerates the elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    It is similar to python's `enumerate`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.enumerate(start=5)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    (5, 1)\u001b[0m\n",
       "\u001b[0;34m    (6, 2)\u001b[0m\n",
       "\u001b[0;34m    (7, 3)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # The (nested) structure of the input dataset determines the\u001b[0m\n",
       "\u001b[0;34m    >>> # structure of elements in the resulting dataset.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([(7, 8), (9, 10)])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.enumerate()\u001b[0m\n",
       "\u001b[0;34m    >>> for element in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    (0, array([7, 8], dtype=int32))\u001b[0m\n",
       "\u001b[0;34m    (1, array([ 9, 10], dtype=int32))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      start: A `tf.int64` scalar `tf.Tensor`, representing the start value for\u001b[0m\n",
       "\u001b[0;34m        enumeration.\u001b[0m\n",
       "\u001b[0;34m      name: Optional. A name for the tf.data operations used by `enumerate`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mmax_value\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miinfo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mas_numpy_dtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mrange_dataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmax_value\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Replicate the range component so that each split is enumerated\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# independently. This avoids the need for prohibitively expensive\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# cross-split coordination.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mrange_dataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_apply_rewrite\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrange_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"replicate_on_split\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mDataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrange_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mshuffle\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreshuffle_each_iteration\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Randomly shuffles the elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This dataset fills a buffer with `buffer_size` elements, then randomly\u001b[0m\n",
       "\u001b[0;34m    samples elements from this buffer, replacing the selected elements with new\u001b[0m\n",
       "\u001b[0;34m    elements. For perfect shuffling, a buffer size greater than or equal to the\u001b[0m\n",
       "\u001b[0;34m    full size of the dataset is required.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For instance, if your dataset contains 10,000 elements but `buffer_size` is\u001b[0m\n",
       "\u001b[0;34m    set to 1,000, then `shuffle` will initially select a random element from\u001b[0m\n",
       "\u001b[0;34m    only the first 1,000 elements in the buffer. Once an element is selected,\u001b[0m\n",
       "\u001b[0;34m    its space in the buffer is replaced by the next (i.e. 1,001-st) element,\u001b[0m\n",
       "\u001b[0;34m    maintaining the 1,000 element buffer.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `reshuffle_each_iteration` controls whether the shuffle order should be\u001b[0m\n",
       "\u001b[0;34m    different for each epoch. In TF 1.X, the idiomatic way to create epochs\u001b[0m\n",
       "\u001b[0;34m    was through the `repeat` transformation:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.shuffle(3, reshuffle_each_iteration=True)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.repeat(2)\u001b[0m\n",
       "\u001b[0;34m    # [1, 0, 2, 1, 2, 0]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.shuffle(3, reshuffle_each_iteration=False)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.repeat(2)\u001b[0m\n",
       "\u001b[0;34m    # [1, 0, 2, 1, 0, 2]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    In TF 2.0, `tf.data.Dataset` objects are Python iterables which makes it\u001b[0m\n",
       "\u001b[0;34m    possible to also create epochs through Python iteration:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.shuffle(3, reshuffle_each_iteration=True)\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [1, 0, 2]\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [1, 2, 0]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.shuffle(3, reshuffle_each_iteration=False)\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [1, 0, 2]\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [1, 0, 2]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Fully shuffling all the data\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    To shuffle an entire dataset, set `buffer_size=dataset.cardinality()`. This\u001b[0m\n",
       "\u001b[0;34m    is equivalent to setting the `buffer_size` equal to the number of elements\u001b[0m\n",
       "\u001b[0;34m    in the dataset, resulting in uniform shuffle.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: `shuffle(dataset.cardinality())` loads the full dataset into memory so\u001b[0m\n",
       "\u001b[0;34m    that it can be shuffled. This will cause a memory overflow (OOM) error if\u001b[0m\n",
       "\u001b[0;34m    the dataset is too large, so full-shuffle should only be used for datasets\u001b[0m\n",
       "\u001b[0;34m    that are known to fit in the memory, such as datasets of filenames or other\u001b[0m\n",
       "\u001b[0;34m    small datasets.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(20)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.shuffle(dataset.cardinality())\u001b[0m\n",
       "\u001b[0;34m    # [18, 4, 9, 2, 17, 8, 5, 10, 0, 6, 16, 3, 19, 7, 14, 11, 15, 13, 12, 1]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      buffer_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        elements from this dataset from which the new dataset will sample. To\u001b[0m\n",
       "\u001b[0;34m        uniformly shuffle the entire dataset, use\u001b[0m\n",
       "\u001b[0;34m        `buffer_size=dataset.cardinality()`.\u001b[0m\n",
       "\u001b[0;34m      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\u001b[0m\n",
       "\u001b[0;34m        seed that will be used to create the distribution. See\u001b[0m\n",
       "\u001b[0;34m        `tf.random.set_seed` for behavior.\u001b[0m\n",
       "\u001b[0;34m      reshuffle_each_iteration: (Optional.) A boolean, which if true indicates\u001b[0m\n",
       "\u001b[0;34m        that the dataset should be pseudorandomly reshuffled each time it is\u001b[0m\n",
       "\u001b[0;34m        iterated over. (Defaults to `True`.)\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mshuffle_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_shuffle\u001b[0m\u001b[0;34m(\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuffer_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreshuffle_each_iteration\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mcache\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfilename\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Caches the elements in this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The first time the dataset is iterated over, its elements will be cached\u001b[0m\n",
       "\u001b[0;34m    either in the specified file or in memory. Subsequent iterations will\u001b[0m\n",
       "\u001b[0;34m    use the cached data.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: To guarantee that the cache gets finalized, the input dataset must be\u001b[0m\n",
       "\u001b[0;34m    iterated through in its entirety, until it raises StopIteration. Otherwise,\u001b[0m\n",
       "\u001b[0;34m    subsequent iterations may not use cached data.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(5)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda x: x**2)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.cache()\u001b[0m\n",
       "\u001b[0;34m    >>> # The first time reading through the data will generate the data using\u001b[0m\n",
       "\u001b[0;34m    >>> # `range` and `map`.\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 4, 9, 16]\u001b[0m\n",
       "\u001b[0;34m    >>> # Subsequent iterations read from the cache.\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 4, 9, 16]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    When caching to a file, the cached data will persist across runs. Even the\u001b[0m\n",
       "\u001b[0;34m    first iteration through the data will read from the cache file. Changing\u001b[0m\n",
       "\u001b[0;34m    the input pipeline before the call to `.cache()` will have no effect until\u001b[0m\n",
       "\u001b[0;34m    the cache file is removed or the filename is changed.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(5)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.cache(\"/path/to/file\")\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.cache(\"/path/to/file\")  # Same file!\u001b[0m\n",
       "\u001b[0;34m    list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    # [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: `cache` will produce exactly the same elements during each iteration\u001b[0m\n",
       "\u001b[0;34m    through the dataset. If you wish to randomize the iteration order, make sure\u001b[0m\n",
       "\u001b[0;34m    to call `shuffle` *after* calling `cache`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      filename: A `tf.string` scalar `tf.Tensor`, representing the name of a\u001b[0m\n",
       "\u001b[0;34m        directory on the filesystem to use for caching elements in this Dataset.\u001b[0m\n",
       "\u001b[0;34m        If a filename is not provided, the dataset will be cached in memory.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> cache_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mcache_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mcache_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_cache\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfilename\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mtake\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` with at most `count` elements from this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.take(3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      count: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        elements of this dataset that should be taken to form the new dataset.\u001b[0m\n",
       "\u001b[0;34m        If `count` is -1, or if `count` is greater than the size of this\u001b[0m\n",
       "\u001b[0;34m        dataset, the new dataset will contain all elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# take_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mtake_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mtake_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_take\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mskip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` that skips `count` elements from this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.skip(7)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [7, 8, 9]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      count: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        elements of this dataset that should be skipped to form the new dataset.\u001b[0m\n",
       "\u001b[0;34m        If `count` is greater than the size of this dataset, the new dataset\u001b[0m\n",
       "\u001b[0;34m        will contain no elements.  If `count` is -1, skips the entire dataset.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# skip_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mskip_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mskip_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_skip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcount\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mshard\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum_shards\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mindex\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` that includes only 1/`num_shards` of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `shard` is deterministic. The Dataset produced by `A.shard(n, i)` will\u001b[0m\n",
       "\u001b[0;34m    contain all elements of A whose index mod n = i.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> A = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> B = A.shard(num_shards=3, index=0)\u001b[0m\n",
       "\u001b[0;34m    >>> list(B.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 3, 6, 9]\u001b[0m\n",
       "\u001b[0;34m    >>> C = A.shard(num_shards=3, index=1)\u001b[0m\n",
       "\u001b[0;34m    >>> list(C.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 4, 7]\u001b[0m\n",
       "\u001b[0;34m    >>> D = A.shard(num_shards=3, index=2)\u001b[0m\n",
       "\u001b[0;34m    >>> list(D.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 5, 8]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This dataset operator is very useful when running distributed training, as\u001b[0m\n",
       "\u001b[0;34m    it allows each worker to read a unique subset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    When reading a single input file, you can shard elements as follows:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    d = tf.data.TFRecordDataset(input_file)\u001b[0m\n",
       "\u001b[0;34m    d = d.shard(num_workers, worker_index)\u001b[0m\n",
       "\u001b[0;34m    d = d.repeat(num_epochs)\u001b[0m\n",
       "\u001b[0;34m    d = d.shuffle(shuffle_buffer_size)\u001b[0m\n",
       "\u001b[0;34m    d = d.map(parser_fn, num_parallel_calls=num_map_threads)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Important caveats:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    - Be sure to shard before you use any randomizing operator (such as\u001b[0m\n",
       "\u001b[0;34m      shuffle).\u001b[0m\n",
       "\u001b[0;34m    - Generally it is best if the shard operator is used early in the dataset\u001b[0m\n",
       "\u001b[0;34m      pipeline. For example, when reading from a set of TFRecord files, shard\u001b[0m\n",
       "\u001b[0;34m      before converting the dataset to input samples. This avoids reading every\u001b[0m\n",
       "\u001b[0;34m      file on every worker. The following is an example of an efficient\u001b[0m\n",
       "\u001b[0;34m      sharding strategy within a complete pipeline:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    d = Dataset.list_files(pattern, shuffle=False)\u001b[0m\n",
       "\u001b[0;34m    d = d.shard(num_workers, worker_index)\u001b[0m\n",
       "\u001b[0;34m    d = d.repeat(num_epochs)\u001b[0m\n",
       "\u001b[0;34m    d = d.shuffle(shuffle_buffer_size)\u001b[0m\n",
       "\u001b[0;34m    d = d.interleave(tf.data.TFRecordDataset,\u001b[0m\n",
       "\u001b[0;34m                     cycle_length=num_readers, block_length=1)\u001b[0m\n",
       "\u001b[0;34m    d = d.map(parser_fn, num_parallel_calls=num_map_threads)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      num_shards: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        shards operating in parallel.\u001b[0m\n",
       "\u001b[0;34m      index: A `tf.int64` scalar `tf.Tensor`, representing the worker index.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      InvalidArgumentError: if `num_shards` or `index` are illegal values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m        Note: error checking is done on a best-effort basis, and errors aren't\u001b[0m\n",
       "\u001b[0;34m        guaranteed to be caught upon dataset creation. (e.g. providing in a\u001b[0m\n",
       "\u001b[0;34m        placeholder tensor bypasses the early checking, and will instead result\u001b[0m\n",
       "\u001b[0;34m        in an error during a session.run call.)\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mshard_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mshard_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_shard\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum_shards\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mindex\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m           \u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m           \u001b[0mcompression\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m           \u001b[0mshard_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m           \u001b[0mcheckpoint_args\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Saves the content of the given dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      Example usage:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      >>> import tempfile\u001b[0m\n",
       "\u001b[0;34m      >>> path = os.path.join(tempfile.gettempdir(), \"saved_data\")\u001b[0m\n",
       "\u001b[0;34m      >>> # Save a dataset\u001b[0m\n",
       "\u001b[0;34m      >>> dataset = tf.data.Dataset.range(2)\u001b[0m\n",
       "\u001b[0;34m      >>> dataset.save(path)\u001b[0m\n",
       "\u001b[0;34m      >>> new_dataset = tf.data.Dataset.load(path)\u001b[0m\n",
       "\u001b[0;34m      >>> for elem in new_dataset:\u001b[0m\n",
       "\u001b[0;34m      ...   print(elem)\u001b[0m\n",
       "\u001b[0;34m      tf.Tensor(0, shape=(), dtype=int64)\u001b[0m\n",
       "\u001b[0;34m      tf.Tensor(1, shape=(), dtype=int64)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      The saved dataset is saved in multiple file \"shards\". By default, the\u001b[0m\n",
       "\u001b[0;34m      dataset output is divided to shards in a round-robin fashion but custom\u001b[0m\n",
       "\u001b[0;34m      sharding can be specified via the `shard_func` function. For example, you\u001b[0m\n",
       "\u001b[0;34m      can save the dataset to using a single shard as follows:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      ```python\u001b[0m\n",
       "\u001b[0;34m      dataset = make_dataset()\u001b[0m\n",
       "\u001b[0;34m      def custom_shard_func(element):\u001b[0m\n",
       "\u001b[0;34m        return np.int64(0)\u001b[0m\n",
       "\u001b[0;34m      dataset.save(\u001b[0m\n",
       "\u001b[0;34m          path=\"/path/to/data\", ..., shard_func=custom_shard_func)\u001b[0m\n",
       "\u001b[0;34m      ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      To enable checkpointing, pass in `checkpoint_args` to the `save` method\u001b[0m\n",
       "\u001b[0;34m      as follows:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      ```python\u001b[0m\n",
       "\u001b[0;34m      dataset = tf.data.Dataset.range(100)\u001b[0m\n",
       "\u001b[0;34m      save_dir = \"...\"\u001b[0m\n",
       "\u001b[0;34m      checkpoint_prefix = \"...\"\u001b[0m\n",
       "\u001b[0;34m      step_counter = tf.Variable(0, trainable=False)\u001b[0m\n",
       "\u001b[0;34m      checkpoint_args = {\u001b[0m\n",
       "\u001b[0;34m        \"checkpoint_interval\": 50,\u001b[0m\n",
       "\u001b[0;34m        \"step_counter\": step_counter,\u001b[0m\n",
       "\u001b[0;34m        \"directory\": checkpoint_prefix,\u001b[0m\n",
       "\u001b[0;34m        \"max_to_keep\": 20,\u001b[0m\n",
       "\u001b[0;34m      }\u001b[0m\n",
       "\u001b[0;34m      dataset.save(dataset, save_dir, checkpoint_args=checkpoint_args)\u001b[0m\n",
       "\u001b[0;34m      ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      NOTE: The directory layout and file format used for saving the dataset is\u001b[0m\n",
       "\u001b[0;34m      considered an implementation detail and may change. For this reason,\u001b[0m\n",
       "\u001b[0;34m      datasets saved through `tf.data.Dataset.save` should only be consumed\u001b[0m\n",
       "\u001b[0;34m      through `tf.data.Dataset.load`, which is guaranteed to be\u001b[0m\n",
       "\u001b[0;34m      backwards compatible.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m     path: Required. A directory to use for saving the dataset.\u001b[0m\n",
       "\u001b[0;34m     compression: Optional. The algorithm to use to compress data when writing\u001b[0m\n",
       "\u001b[0;34m          it. Supported options are `GZIP` and `NONE`. Defaults to `NONE`.\u001b[0m\n",
       "\u001b[0;34m     shard_func: Optional. A function to control the mapping of dataset\u001b[0m\n",
       "\u001b[0;34m          elements to file shards. The function is expected to map elements of\u001b[0m\n",
       "\u001b[0;34m          the input dataset to int64 shard IDs. If present, the function will be\u001b[0m\n",
       "\u001b[0;34m          traced and executed as graph computation.\u001b[0m\n",
       "\u001b[0;34m     checkpoint_args: Optional args for checkpointing which will be passed into\u001b[0m\n",
       "\u001b[0;34m          the `tf.train.CheckpointManager`. If `checkpoint_args` are not\u001b[0m\n",
       "\u001b[0;34m          specified, then checkpointing will not be performed. The `save()`\u001b[0m\n",
       "\u001b[0;34m          implementation creates a `tf.train.Checkpoint` object internally, so\u001b[0m\n",
       "\u001b[0;34m          users should not set the `checkpoint` argument in `checkpoint_args`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      An operation which when executed performs the save. When writing\u001b[0m\n",
       "\u001b[0;34m      checkpoints, returns None. The return value is useful in unit tests.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError if `checkpoint` is passed into `checkpoint_args`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> save_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0msave_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0msave_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_save\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcompression\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mshard_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcheckpoint_args\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mload\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0melement_spec\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcompression\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreader_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Loads a previously saved dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Example usage:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> import tempfile\u001b[0m\n",
       "\u001b[0;34m    >>> path = os.path.join(tempfile.gettempdir(), \"saved_data\")\u001b[0m\n",
       "\u001b[0;34m    >>> # Save a dataset\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(2)\u001b[0m\n",
       "\u001b[0;34m    >>> tf.data.Dataset.save(dataset, path)\u001b[0m\n",
       "\u001b[0;34m    >>> new_dataset = tf.data.Dataset.load(path)\u001b[0m\n",
       "\u001b[0;34m    >>> for elem in new_dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(elem)\u001b[0m\n",
       "\u001b[0;34m    tf.Tensor(0, shape=(), dtype=int64)\u001b[0m\n",
       "\u001b[0;34m    tf.Tensor(1, shape=(), dtype=int64)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    If the default option of sharding the saved dataset was used, the element\u001b[0m\n",
       "\u001b[0;34m    order of the saved dataset will be preserved when loading it.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `reader_func` argument can be used to specify a custom order in which\u001b[0m\n",
       "\u001b[0;34m    elements should be loaded from the individual shards. The `reader_func` is\u001b[0m\n",
       "\u001b[0;34m    expected to take a single argument -- a dataset of datasets, each containing\u001b[0m\n",
       "\u001b[0;34m    elements of one of the shards -- and return a dataset of elements. For\u001b[0m\n",
       "\u001b[0;34m    example, the order of shards can be shuffled when loading them as follows:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    def custom_reader_func(datasets):\u001b[0m\n",
       "\u001b[0;34m      datasets = datasets.shuffle(NUM_SHARDS)\u001b[0m\n",
       "\u001b[0;34m      return datasets.interleave(lambda x: x, num_parallel_calls=AUTOTUNE)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    dataset = tf.data.Dataset.load(\u001b[0m\n",
       "\u001b[0;34m        path=\"/path/to/data\", ..., reader_func=custom_reader_func)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      path: Required. A path pointing to a previously saved dataset.\u001b[0m\n",
       "\u001b[0;34m      element_spec: Optional. A nested structure of `tf.TypeSpec` objects\u001b[0m\n",
       "\u001b[0;34m        matching the structure of an element of the saved dataset and specifying\u001b[0m\n",
       "\u001b[0;34m        the type of individual element components. If not provided, the nested\u001b[0m\n",
       "\u001b[0;34m        structure of `tf.TypeSpec` saved with the saved dataset is used. Note\u001b[0m\n",
       "\u001b[0;34m        that this argument is required in graph mode.\u001b[0m\n",
       "\u001b[0;34m      compression: Optional. The algorithm to use to decompress the data when\u001b[0m\n",
       "\u001b[0;34m        reading it. Supported options are `GZIP` and `NONE`. Defaults to `NONE`.\u001b[0m\n",
       "\u001b[0;34m      reader_func: Optional. A function to control how to read data from shards.\u001b[0m\n",
       "\u001b[0;34m        If present, the function will be traced and executed as graph\u001b[0m\n",
       "\u001b[0;34m        computation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A `tf.data.Dataset` instance.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      FileNotFoundError: If `element_spec` is not specified and the saved nested\u001b[0m\n",
       "\u001b[0;34m        structure of `tf.TypeSpec` can not be located with the saved dataset.\u001b[0m\n",
       "\u001b[0;34m      ValueError: If `element_spec` is not specified and the method is executed\u001b[0m\n",
       "\u001b[0;34m        in graph mode.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> load_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mload_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mload_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_load\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mpath\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0melement_spec\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mcompression\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mcompression\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mreader_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mreader_func\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mbatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdeterministic\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Combines consecutive elements of this dataset into batches.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(8)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.batch(3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(8)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.batch(3, drop_remainder=True)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [array([0, 1, 2]), array([3, 4, 5])]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The components of the resulting element will have an additional outer\u001b[0m\n",
       "\u001b[0;34m    dimension, which will be `batch_size` (or `N % batch_size` for the last\u001b[0m\n",
       "\u001b[0;34m    element if `batch_size` does not divide the number of input elements `N`\u001b[0m\n",
       "\u001b[0;34m    evenly and `drop_remainder` is `False`). If your program depends on the\u001b[0m\n",
       "\u001b[0;34m    batches having the same outer dimension, you should set the `drop_remainder`\u001b[0m\n",
       "\u001b[0;34m    argument to `True` to prevent the smaller batch from being produced.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: If your program requires data to have a statically known shape (e.g.,\u001b[0m\n",
       "\u001b[0;34m    when using XLA), you should use `drop_remainder=True`. Without\u001b[0m\n",
       "\u001b[0;34m    `drop_remainder=True` the shape of the output dataset will have an unknown\u001b[0m\n",
       "\u001b[0;34m    leading dimension due to the possibility of a smaller final batch.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        consecutive elements of this dataset to combine in a single batch.\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last batch should be dropped in the case it has fewer than\u001b[0m\n",
       "\u001b[0;34m        `batch_size` elements; the default behavior is not to drop the smaller\u001b[0m\n",
       "\u001b[0;34m        batch.\u001b[0m\n",
       "\u001b[0;34m      num_parallel_calls: (Optional.) A `tf.int64` scalar `tf.Tensor`,\u001b[0m\n",
       "\u001b[0;34m        representing the number of batches to compute asynchronously in\u001b[0m\n",
       "\u001b[0;34m        parallel.\u001b[0m\n",
       "\u001b[0;34m        If not specified, batches will be computed sequentially. If the value\u001b[0m\n",
       "\u001b[0;34m        `tf.data.AUTOTUNE` is used, then the number of parallel\u001b[0m\n",
       "\u001b[0;34m        calls is set dynamically based on available resources.\u001b[0m\n",
       "\u001b[0;34m      deterministic: (Optional.) When `num_parallel_calls` is specified, if this\u001b[0m\n",
       "\u001b[0;34m        boolean is specified (`True` or `False`), it controls the order in which\u001b[0m\n",
       "\u001b[0;34m        the transformation produces elements. If set to `False`, the\u001b[0m\n",
       "\u001b[0;34m        transformation is allowed to yield elements out of order to trade\u001b[0m\n",
       "\u001b[0;34m        determinism for performance. If not specified, the\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Options.deterministic` option (`True` by default) controls the\u001b[0m\n",
       "\u001b[0;34m        behavior.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> batch_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access,redefined-outer-name\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mbatch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mbatch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                           \u001b[0mdeterministic\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access,redefined-outer-name\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mpadded_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpadded_shapes\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpadding_values\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Combines consecutive elements of this dataset into padded batches.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This transformation combines multiple consecutive elements of the input\u001b[0m\n",
       "\u001b[0;34m    dataset into a single element.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Like `tf.data.Dataset.batch`, the components of the resulting element will\u001b[0m\n",
       "\u001b[0;34m    have an additional outer dimension, which will be `batch_size` (or\u001b[0m\n",
       "\u001b[0;34m    `N % batch_size` for the last element if `batch_size` does not divide the\u001b[0m\n",
       "\u001b[0;34m    number of input elements `N` evenly and `drop_remainder` is `False`). If\u001b[0m\n",
       "\u001b[0;34m    your program depends on the batches having the same outer dimension, you\u001b[0m\n",
       "\u001b[0;34m    should set the `drop_remainder` argument to `True` to prevent the smaller\u001b[0m\n",
       "\u001b[0;34m    batch from being produced.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Unlike `tf.data.Dataset.batch`, the input elements to be batched may have\u001b[0m\n",
       "\u001b[0;34m    different shapes, and this transformation will pad each component to the\u001b[0m\n",
       "\u001b[0;34m    respective shape in `padded_shapes`. The `padded_shapes` argument\u001b[0m\n",
       "\u001b[0;34m    determines the resulting shape for each dimension of each component in an\u001b[0m\n",
       "\u001b[0;34m    output element:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    * If the dimension is a constant, the component will be padded out to that\u001b[0m\n",
       "\u001b[0;34m      length in that dimension.\u001b[0m\n",
       "\u001b[0;34m    * If the dimension is unknown, the component will be padded out to the\u001b[0m\n",
       "\u001b[0;34m      maximum length of all elements in that dimension.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> A = (tf.data.Dataset\u001b[0m\n",
       "\u001b[0;34m    ...      .range(1, 5, output_type=tf.int32)\u001b[0m\n",
       "\u001b[0;34m    ...      .map(lambda x: tf.fill([x], x)))\u001b[0m\n",
       "\u001b[0;34m    >>> # Pad to the smallest per-batch size that fits all elements.\u001b[0m\n",
       "\u001b[0;34m    >>> B = A.padded_batch(2)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in B.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    [[1 0]\u001b[0m\n",
       "\u001b[0;34m     [2 2]]\u001b[0m\n",
       "\u001b[0;34m    [[3 3 3 0]\u001b[0m\n",
       "\u001b[0;34m     [4 4 4 4]]\u001b[0m\n",
       "\u001b[0;34m    >>> # Pad to a fixed size.\u001b[0m\n",
       "\u001b[0;34m    >>> C = A.padded_batch(2, padded_shapes=5)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in C.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    [[1 0 0 0 0]\u001b[0m\n",
       "\u001b[0;34m     [2 2 0 0 0]]\u001b[0m\n",
       "\u001b[0;34m    [[3 3 3 0 0]\u001b[0m\n",
       "\u001b[0;34m     [4 4 4 4 0]]\u001b[0m\n",
       "\u001b[0;34m    >>> # Pad with a custom value.\u001b[0m\n",
       "\u001b[0;34m    >>> D = A.padded_batch(2, padded_shapes=5, padding_values=-1)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in D.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    [[ 1 -1 -1 -1 -1]\u001b[0m\n",
       "\u001b[0;34m     [ 2  2 -1 -1 -1]]\u001b[0m\n",
       "\u001b[0;34m    [[ 3  3  3 -1 -1]\u001b[0m\n",
       "\u001b[0;34m     [ 4  4  4  4 -1]]\u001b[0m\n",
       "\u001b[0;34m    >>> # Components of nested elements can be padded independently.\u001b[0m\n",
       "\u001b[0;34m    >>> elements = [([1, 2, 3], [10]),\u001b[0m\n",
       "\u001b[0;34m    ...             ([4, 5], [11, 12])]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(\u001b[0m\n",
       "\u001b[0;34m    ...     lambda: iter(elements), (tf.int32, tf.int32))\u001b[0m\n",
       "\u001b[0;34m    >>> # Pad the first component of the tuple to length 4, and the second\u001b[0m\n",
       "\u001b[0;34m    >>> # component to the smallest size that fits.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.padded_batch(2,\u001b[0m\n",
       "\u001b[0;34m    ...     padded_shapes=([4], [None]),\u001b[0m\n",
       "\u001b[0;34m    ...     padding_values=(-1, 100))\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [(array([[ 1,  2,  3, -1], [ 4,  5, -1, -1]], dtype=int32),\u001b[0m\n",
       "\u001b[0;34m      array([[ 10, 100], [ 11,  12]], dtype=int32))]\u001b[0m\n",
       "\u001b[0;34m    >>> # Pad with a single value and multiple components.\u001b[0m\n",
       "\u001b[0;34m    >>> E = tf.data.Dataset.zip((A, A)).padded_batch(2, padding_values=-1)\u001b[0m\n",
       "\u001b[0;34m    >>> for element in E.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(element)\u001b[0m\n",
       "\u001b[0;34m    (array([[ 1, -1],\u001b[0m\n",
       "\u001b[0;34m           [ 2,  2]], dtype=int32), array([[ 1, -1],\u001b[0m\n",
       "\u001b[0;34m           [ 2,  2]], dtype=int32))\u001b[0m\n",
       "\u001b[0;34m    (array([[ 3,  3,  3, -1],\u001b[0m\n",
       "\u001b[0;34m           [ 4,  4,  4,  4]], dtype=int32), array([[ 3,  3,  3, -1],\u001b[0m\n",
       "\u001b[0;34m           [ 4,  4,  4,  4]], dtype=int32))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    See also `tf.data.experimental.dense_to_sparse_batch`, which combines\u001b[0m\n",
       "\u001b[0;34m    elements that may have different shapes into a `tf.sparse.SparseTensor`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        consecutive elements of this dataset to combine in a single batch.\u001b[0m\n",
       "\u001b[0;34m      padded_shapes: (Optional.) A (nested) structure of `tf.TensorShape` or\u001b[0m\n",
       "\u001b[0;34m        `tf.int64` vector tensor-like objects representing the shape to which\u001b[0m\n",
       "\u001b[0;34m        the respective component of each input element should be padded prior\u001b[0m\n",
       "\u001b[0;34m        to batching. Any unknown dimensions will be padded to the maximum size\u001b[0m\n",
       "\u001b[0;34m        of that dimension in each batch. If unset, all dimensions of all\u001b[0m\n",
       "\u001b[0;34m        components are padded to the maximum size in the batch. `padded_shapes`\u001b[0m\n",
       "\u001b[0;34m        must be set if any component has an unknown rank.\u001b[0m\n",
       "\u001b[0;34m      padding_values: (Optional.) A (nested) structure of scalar-shaped\u001b[0m\n",
       "\u001b[0;34m        `tf.Tensor`, representing the padding values to use for the respective\u001b[0m\n",
       "\u001b[0;34m        components. None represents that the (nested) structure should be padded\u001b[0m\n",
       "\u001b[0;34m        with default values.  Defaults are `0` for numeric types and the empty\u001b[0m\n",
       "\u001b[0;34m        string for string types. The `padding_values` should have the same\u001b[0m\n",
       "\u001b[0;34m        (nested) structure as the input dataset. If `padding_values` is a single\u001b[0m\n",
       "\u001b[0;34m        element and the input dataset has multiple components, then the same\u001b[0m\n",
       "\u001b[0;34m        `padding_values` will be used to pad every component of the dataset.\u001b[0m\n",
       "\u001b[0;34m        If `padding_values` is a scalar, then its value will be broadcasted\u001b[0m\n",
       "\u001b[0;34m        to match the shape of each component.\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last batch should be dropped in the case it has fewer than\u001b[0m\n",
       "\u001b[0;34m        `batch_size` elements; the default behavior is not to drop the smaller\u001b[0m\n",
       "\u001b[0;34m        batch.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError: If a component has an unknown rank, and the `padded_shapes`\u001b[0m\n",
       "\u001b[0;34m        argument is not set.\u001b[0m\n",
       "\u001b[0;34m      TypeError: If a component is of an unsupported type. The list of supported\u001b[0m\n",
       "\u001b[0;34m        types is documented in\u001b[0m\n",
       "\u001b[0;34m        https://www.tensorflow.org/guide/data#dataset_structure.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# padded_batch_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mpadded_batch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mpadded_batch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_padded_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpadded_shapes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                         \u001b[0mpadding_values\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mragged_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mrow_splits_dtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Combines consecutive elements of this dataset into `tf.RaggedTensor`s.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Like `tf.data.Dataset.batch`, the components of the resulting element will\u001b[0m\n",
       "\u001b[0;34m    have an additional outer dimension, which will be `batch_size` (or\u001b[0m\n",
       "\u001b[0;34m    `N % batch_size` for the last element if `batch_size` does not divide the\u001b[0m\n",
       "\u001b[0;34m    number of input elements `N` evenly and `drop_remainder` is `False`). If\u001b[0m\n",
       "\u001b[0;34m    your program depends on the batches having the same outer dimension, you\u001b[0m\n",
       "\u001b[0;34m    should set the `drop_remainder` argument to `True` to prevent the smaller\u001b[0m\n",
       "\u001b[0;34m    batch from being produced.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Unlike `tf.data.Dataset.batch`, the input elements to be batched may have\u001b[0m\n",
       "\u001b[0;34m    different shapes:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    *  If an input element is a `tf.Tensor` whose static `tf.TensorShape` is\u001b[0m\n",
       "\u001b[0;34m    fully defined, then it is batched as normal.\u001b[0m\n",
       "\u001b[0;34m    *  If an input element is a `tf.Tensor` whose static `tf.TensorShape`\u001b[0m\n",
       "\u001b[0;34m    contains one or more axes with unknown size (i.e., `shape[i]=None`), then\u001b[0m\n",
       "\u001b[0;34m    the output will contain a `tf.RaggedTensor` that is ragged up to any of such\u001b[0m\n",
       "\u001b[0;34m    dimensions.\u001b[0m\n",
       "\u001b[0;34m    *  If an input element is a `tf.RaggedTensor` or any other type, then it is\u001b[0m\n",
       "\u001b[0;34m    batched as normal.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(6)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda x: tf.range(x))\u001b[0m\n",
       "\u001b[0;34m    >>> dataset.element_spec.shape\u001b[0m\n",
       "\u001b[0;34m    TensorShape([None])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.ragged_batch(2)\u001b[0m\n",
       "\u001b[0;34m    >>> for batch in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(batch)\u001b[0m\n",
       "\u001b[0;34m    <tf.RaggedTensor [[], [0]]>\u001b[0m\n",
       "\u001b[0;34m    <tf.RaggedTensor [[0, 1], [0, 1, 2]]>\u001b[0m\n",
       "\u001b[0;34m    <tf.RaggedTensor [[0, 1, 2, 3], [0, 1, 2, 3, 4]]>\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        consecutive elements of this dataset to combine in a single batch.\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last batch should be dropped in the case it has fewer than\u001b[0m\n",
       "\u001b[0;34m        `batch_size` elements; the default behavior is not to drop the smaller\u001b[0m\n",
       "\u001b[0;34m        batch.\u001b[0m\n",
       "\u001b[0;34m      row_splits_dtype: The dtype that should be used for the `row_splits` of\u001b[0m\n",
       "\u001b[0;34m        any new ragged tensors.  Existing `tf.RaggedTensor` elements do not have\u001b[0m\n",
       "\u001b[0;34m        their row_splits dtype changed.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A string indicating a name for the `tf.data` operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# ragged_batch_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mragged_batch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mragged_batch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_ragged_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                         \u001b[0mrow_splits_dtype\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0msparse_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrow_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Combines consecutive elements into `tf.sparse.SparseTensor`s.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Like `Dataset.padded_batch()`, this transformation combines multiple\u001b[0m\n",
       "\u001b[0;34m    consecutive elements of the dataset, which might have different\u001b[0m\n",
       "\u001b[0;34m    shapes, into a single element. The resulting element has three\u001b[0m\n",
       "\u001b[0;34m    components (`indices`, `values`, and `dense_shape`), which\u001b[0m\n",
       "\u001b[0;34m    comprise a `tf.sparse.SparseTensor` that represents the same data. The\u001b[0m\n",
       "\u001b[0;34m    `row_shape` represents the dense shape of each row in the\u001b[0m\n",
       "\u001b[0;34m    resulting `tf.sparse.SparseTensor`, to which the effective batch size is\u001b[0m\n",
       "\u001b[0;34m    prepended. For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    # NOTE: The following examples use `{ ... }` to represent the\u001b[0m\n",
       "\u001b[0;34m    # contents of a dataset.\u001b[0m\n",
       "\u001b[0;34m    a = { ['a', 'b', 'c'], ['a', 'b'], ['a', 'b', 'c', 'd'] }\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    a.apply(tf.data.experimental.dense_to_sparse_batch(\u001b[0m\n",
       "\u001b[0;34m        batch_size=2, row_shape=[6])) ==\u001b[0m\n",
       "\u001b[0;34m    {\u001b[0m\n",
       "\u001b[0;34m        ([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1]],  # indices\u001b[0m\n",
       "\u001b[0;34m         ['a', 'b', 'c', 'a', 'b'],                 # values\u001b[0m\n",
       "\u001b[0;34m         [2, 6]),                                   # dense_shape\u001b[0m\n",
       "\u001b[0;34m        ([[0, 0], [0, 1], [0, 2], [0, 3]],\u001b[0m\n",
       "\u001b[0;34m         ['a', 'b', 'c', 'd'],\u001b[0m\n",
       "\u001b[0;34m         [1, 6])\u001b[0m\n",
       "\u001b[0;34m    }\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      batch_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        consecutive elements of this dataset to combine in a single batch.\u001b[0m\n",
       "\u001b[0;34m      row_shape: A `tf.TensorShape` or `tf.int64` vector tensor-like object\u001b[0m\n",
       "\u001b[0;34m        representing the equivalent dense shape of a row in the resulting\u001b[0m\n",
       "\u001b[0;34m        `tf.sparse.SparseTensor`. Each element of this dataset must have the\u001b[0m\n",
       "\u001b[0;34m        same rank as `row_shape`, and must have size less than or equal to\u001b[0m\n",
       "\u001b[0;34m        `row_shape` in each dimension.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A string indicating a name for the `tf.data` operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# sparse_batch_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0msparse_batch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0msparse_batch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sparse_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrow_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdeterministic\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Maps `map_func` across the elements of this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This transformation applies `map_func` to each element of this dataset, and\u001b[0m\n",
       "\u001b[0;34m    returns a new dataset containing the transformed elements, in the same\u001b[0m\n",
       "\u001b[0;34m    order as they appeared in the input. `map_func` can be used to change both\u001b[0m\n",
       "\u001b[0;34m    the values and the structure of a dataset's elements. Supported structure\u001b[0m\n",
       "\u001b[0;34m    constructs are documented\u001b[0m\n",
       "\u001b[0;34m    [here](https://www.tensorflow.org/guide/data#dataset_structure).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, `map` can be used for adding 1 to each element, or projecting a\u001b[0m\n",
       "\u001b[0;34m    subset of element components.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda x: x + 1)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [2, 3, 4, 5, 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The input signature of `map_func` is determined by the structure of each\u001b[0m\n",
       "\u001b[0;34m    element in this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.range(5)\u001b[0m\n",
       "\u001b[0;34m    >>> # `map_func` takes a single argument of type `tf.Tensor` with the same\u001b[0m\n",
       "\u001b[0;34m    >>> # shape and dtype.\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(lambda x: x + 1)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Each element is a tuple containing two `tf.Tensor` objects.\u001b[0m\n",
       "\u001b[0;34m    >>> elements = [(1, \"foo\"), (2, \"bar\"), (3, \"baz\")]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(\u001b[0m\n",
       "\u001b[0;34m    ...     lambda: elements, (tf.int32, tf.string))\u001b[0m\n",
       "\u001b[0;34m    >>> # `map_func` takes two arguments of type `tf.Tensor`. This function\u001b[0m\n",
       "\u001b[0;34m    >>> # projects out just the first component.\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(lambda x_int, y_str: x_int)\u001b[0m\n",
       "\u001b[0;34m    >>> list(result.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Each element is a dictionary mapping strings to `tf.Tensor` objects.\u001b[0m\n",
       "\u001b[0;34m    >>> elements =  ([{\"a\": 1, \"b\": \"foo\"},\u001b[0m\n",
       "\u001b[0;34m    ...               {\"a\": 2, \"b\": \"bar\"},\u001b[0m\n",
       "\u001b[0;34m    ...               {\"a\": 3, \"b\": \"baz\"}])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(\u001b[0m\n",
       "\u001b[0;34m    ...     lambda: elements, {\"a\": tf.int32, \"b\": tf.string})\u001b[0m\n",
       "\u001b[0;34m    >>> # `map_func` takes a single argument of type `dict` with the same keys\u001b[0m\n",
       "\u001b[0;34m    >>> # as the elements.\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(lambda d: str(d[\"a\"]) + d[\"b\"])\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The value or values returned by `map_func` determine the structure of each\u001b[0m\n",
       "\u001b[0;34m    element in the returned dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(3)\u001b[0m\n",
       "\u001b[0;34m    >>> # `map_func` returns two `tf.Tensor` objects.\u001b[0m\n",
       "\u001b[0;34m    >>> def g(x):\u001b[0m\n",
       "\u001b[0;34m    ...   return tf.constant(37.0), tf.constant([\"Foo\", \"Bar\", \"Baz\"])\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(g)\u001b[0m\n",
       "\u001b[0;34m    >>> result.element_spec\u001b[0m\n",
       "\u001b[0;34m    (TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(3,), \\\u001b[0m\n",
       "\u001b[0;34mdtype=tf.string, name=None))\u001b[0m\n",
       "\u001b[0;34m    >>> # Python primitives, lists, and NumPy arrays are implicitly converted to\u001b[0m\n",
       "\u001b[0;34m    >>> # `tf.Tensor`.\u001b[0m\n",
       "\u001b[0;34m    >>> def h(x):\u001b[0m\n",
       "\u001b[0;34m    ...   return 37.0, [\"Foo\", \"Bar\"], np.array([1.0, 2.0], dtype=np.float64)\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(h)\u001b[0m\n",
       "\u001b[0;34m    >>> result.element_spec\u001b[0m\n",
       "\u001b[0;34m    (TensorSpec(shape=(), dtype=tf.float32, name=None), TensorSpec(shape=(2,), \\\u001b[0m\n",
       "\u001b[0;34mdtype=tf.string, name=None), TensorSpec(shape=(2,), dtype=tf.float64, \\\u001b[0m\n",
       "\u001b[0;34mname=None))\u001b[0m\n",
       "\u001b[0;34m    >>> # `map_func` can return nested structures.\u001b[0m\n",
       "\u001b[0;34m    >>> def i(x):\u001b[0m\n",
       "\u001b[0;34m    ...   return (37.0, [42, 16]), \"foo\"\u001b[0m\n",
       "\u001b[0;34m    >>> result = dataset.map(i)\u001b[0m\n",
       "\u001b[0;34m    >>> result.element_spec\u001b[0m\n",
       "\u001b[0;34m    ((TensorSpec(shape=(), dtype=tf.float32, name=None),\u001b[0m\n",
       "\u001b[0;34m      TensorSpec(shape=(2,), dtype=tf.int32, name=None)),\u001b[0m\n",
       "\u001b[0;34m     TensorSpec(shape=(), dtype=tf.string, name=None))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `map_func` can accept as arguments and return any type of dataset element.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note that irrespective of the context in which `map_func` is defined (eager\u001b[0m\n",
       "\u001b[0;34m    vs. graph), tf.data traces the function and executes it as a graph. To use\u001b[0m\n",
       "\u001b[0;34m    Python code inside of the function you have a few options:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    1) Rely on AutoGraph to convert Python code into an equivalent graph\u001b[0m\n",
       "\u001b[0;34m    computation. The downside of this approach is that AutoGraph can convert\u001b[0m\n",
       "\u001b[0;34m    some but not all Python code.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    2) Use `tf.py_function`, which allows you to write arbitrary Python code but\u001b[0m\n",
       "\u001b[0;34m    will generally result in worse performance than 1). For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])\u001b[0m\n",
       "\u001b[0;34m    >>> # transform a string tensor to upper case string using a Python function\u001b[0m\n",
       "\u001b[0;34m    >>> def upper_case_fn(t: tf.Tensor):\u001b[0m\n",
       "\u001b[0;34m    ...   return t.numpy().decode('utf-8').upper()\u001b[0m\n",
       "\u001b[0;34m    >>> d = d.map(lambda x: tf.py_function(func=upper_case_fn,\u001b[0m\n",
       "\u001b[0;34m    ...           inp=[x], Tout=tf.string))\u001b[0m\n",
       "\u001b[0;34m    >>> list(d.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [b'HELLO', b'WORLD']\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    3) Use `tf.numpy_function`, which also allows you to write arbitrary\u001b[0m\n",
       "\u001b[0;34m    Python code. Note that `tf.py_function` accepts `tf.Tensor` whereas\u001b[0m\n",
       "\u001b[0;34m    `tf.numpy_function` accepts numpy arrays and returns only numpy arrays.\u001b[0m\n",
       "\u001b[0;34m    For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> d = tf.data.Dataset.from_tensor_slices(['hello', 'world'])\u001b[0m\n",
       "\u001b[0;34m    >>> def upper_case_fn(t: np.ndarray):\u001b[0m\n",
       "\u001b[0;34m    ...   return t.decode('utf-8').upper()\u001b[0m\n",
       "\u001b[0;34m    >>> d = d.map(lambda x: tf.numpy_function(func=upper_case_fn,\u001b[0m\n",
       "\u001b[0;34m    ...           inp=[x], Tout=tf.string))\u001b[0m\n",
       "\u001b[0;34m    >>> list(d.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [b'HELLO', b'WORLD']\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note that the use of `tf.numpy_function` and `tf.py_function`\u001b[0m\n",
       "\u001b[0;34m    in general precludes the possibility of executing user-defined\u001b[0m\n",
       "\u001b[0;34m    transformations in parallel (because of Python GIL).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Performance can often be improved by setting `num_parallel_calls` so that\u001b[0m\n",
       "\u001b[0;34m    `map` will use multiple threads to process elements. If deterministic order\u001b[0m\n",
       "\u001b[0;34m    isn't required, it can also improve performance to set\u001b[0m\n",
       "\u001b[0;34m    `deterministic=False`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda x: x + 1,\u001b[0m\n",
       "\u001b[0;34m    ...     num_parallel_calls=tf.data.AUTOTUNE,\u001b[0m\n",
       "\u001b[0;34m    ...     deterministic=False)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The order of elements yielded by this transformation is deterministic if\u001b[0m\n",
       "\u001b[0;34m    `deterministic=True`. If `map_func` contains stateful operations and\u001b[0m\n",
       "\u001b[0;34m    `num_parallel_calls > 1`, the order in which that state is accessed is\u001b[0m\n",
       "\u001b[0;34m    undefined, so the values of output elements may not be deterministic\u001b[0m\n",
       "\u001b[0;34m    regardless of the `deterministic` flag value.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      map_func: A function mapping a dataset element to another dataset element.\u001b[0m\n",
       "\u001b[0;34m      num_parallel_calls: (Optional.) A `tf.int64` scalar `tf.Tensor`,\u001b[0m\n",
       "\u001b[0;34m        representing the number elements to process asynchronously in parallel.\u001b[0m\n",
       "\u001b[0;34m        If not specified, elements will be processed sequentially. If the value\u001b[0m\n",
       "\u001b[0;34m        `tf.data.AUTOTUNE` is used, then the number of parallel\u001b[0m\n",
       "\u001b[0;34m        calls is set dynamically based on available CPU.\u001b[0m\n",
       "\u001b[0;34m      deterministic: (Optional.) When `num_parallel_calls` is specified, if this\u001b[0m\n",
       "\u001b[0;34m        boolean is specified (`True` or `False`), it controls the order in which\u001b[0m\n",
       "\u001b[0;34m        the transformation produces elements. If set to `False`, the\u001b[0m\n",
       "\u001b[0;34m        transformation is allowed to yield elements out of order to trade\u001b[0m\n",
       "\u001b[0;34m        determinism for performance. If not specified, the\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Options.deterministic` option (`True` by default) controls the\u001b[0m\n",
       "\u001b[0;34m        behavior.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> map_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mmap_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mmap_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_map_v2\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mdeterministic\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdeterministic\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mflat_map\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Maps `map_func` across this dataset and flattens the result.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The type signature is:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    def flat_map(\u001b[0m\n",
       "\u001b[0;34m      self: Dataset[T],\u001b[0m\n",
       "\u001b[0;34m      map_func: Callable[[T], Dataset[S]]\u001b[0m\n",
       "\u001b[0;34m    ) -> Dataset[S]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Use `flat_map` if you want to make sure that the order of your dataset\u001b[0m\n",
       "\u001b[0;34m    stays the same. For example, to flatten a dataset of batches into a\u001b[0m\n",
       "\u001b[0;34m    dataset of their elements:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(\u001b[0m\n",
       "\u001b[0;34m    ...     [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.flat_map(tf.data.Dataset.from_tensor_slices)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3, 4, 5, 6, 7, 8, 9]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `tf.data.Dataset.interleave()` is a generalization of `flat_map`, since\u001b[0m\n",
       "\u001b[0;34m    `flat_map` produces the same output as\u001b[0m\n",
       "\u001b[0;34m    `tf.data.Dataset.interleave(cycle_length=1)`\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      map_func: A function mapping a dataset element to a dataset.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> flat_map_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mflat_map_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mflat_map_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_map\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mignore_errors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlog_warning\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Drops elements that cause errors.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1., 2., 0., 4.])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda x: tf.debugging.check_numerics(1. / x, \"\"))\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    Traceback (most recent call last):\u001b[0m\n",
       "\u001b[0;34m    ...\u001b[0m\n",
       "\u001b[0;34m    InvalidArgumentError: ... Tensor had Inf values\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.ignore_errors()\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1.0, 0.5, 0.25]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      log_warning: (Optional.) A bool indicating whether or not ignored errors\u001b[0m\n",
       "\u001b[0;34m        should be logged to stderr. Defaults to `False`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A string indicating a name for the `tf.data` operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# ignore_errors_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mignore_errors_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mignore_errors_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_ignore_errors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlog_warning\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0minterleave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mcycle_length\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mblock_length\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdeterministic\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Maps `map_func` across this dataset, and interleaves the results.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The type signature is:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    def interleave(\u001b[0m\n",
       "\u001b[0;34m      self: Dataset[T],\u001b[0m\n",
       "\u001b[0;34m      map_func: Callable[[T], Dataset[S]]\u001b[0m\n",
       "\u001b[0;34m    ) -> Dataset[S]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, you can use `Dataset.interleave()` to process many input files\u001b[0m\n",
       "\u001b[0;34m    concurrently:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> # Preprocess 4 files concurrently, and interleave blocks of 16 records\u001b[0m\n",
       "\u001b[0;34m    >>> # from each file.\u001b[0m\n",
       "\u001b[0;34m    >>> filenames = [\"/var/data/file1.txt\", \"/var/data/file2.txt\",\u001b[0m\n",
       "\u001b[0;34m    ...              \"/var/data/file3.txt\", \"/var/data/file4.txt\"]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(filenames)\u001b[0m\n",
       "\u001b[0;34m    >>> def parse_fn(filename):\u001b[0m\n",
       "\u001b[0;34m    ...   return tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.interleave(lambda x:\u001b[0m\n",
       "\u001b[0;34m    ...     tf.data.TextLineDataset(x).map(parse_fn, num_parallel_calls=1),\u001b[0m\n",
       "\u001b[0;34m    ...     cycle_length=4, block_length=16)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `cycle_length` and `block_length` arguments control the order in which\u001b[0m\n",
       "\u001b[0;34m    elements are produced. `cycle_length` controls the number of input elements\u001b[0m\n",
       "\u001b[0;34m    that are processed concurrently. If you set `cycle_length` to 1, this\u001b[0m\n",
       "\u001b[0;34m    transformation will handle one input element at a time, and will produce\u001b[0m\n",
       "\u001b[0;34m    identical results to `tf.data.Dataset.flat_map`. In general,\u001b[0m\n",
       "\u001b[0;34m    this transformation will apply `map_func` to `cycle_length` input elements,\u001b[0m\n",
       "\u001b[0;34m    open iterators on the returned `Dataset` objects, and cycle through them\u001b[0m\n",
       "\u001b[0;34m    producing `block_length` consecutive elements from each iterator, and\u001b[0m\n",
       "\u001b[0;34m    consuming the next input element each time it reaches the end of an\u001b[0m\n",
       "\u001b[0;34m    iterator.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = Dataset.range(1, 6)  # ==> [ 1, 2, 3, 4, 5 ]\u001b[0m\n",
       "\u001b[0;34m    >>> # NOTE: New lines indicate \"block\" boundaries.\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.interleave(\u001b[0m\n",
       "\u001b[0;34m    ...     lambda x: Dataset.from_tensors(x).repeat(6),\u001b[0m\n",
       "\u001b[0;34m    ...     cycle_length=2, block_length=4)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 1, 1, 1,\u001b[0m\n",
       "\u001b[0;34m     2, 2, 2, 2,\u001b[0m\n",
       "\u001b[0;34m     1, 1,\u001b[0m\n",
       "\u001b[0;34m     2, 2,\u001b[0m\n",
       "\u001b[0;34m     3, 3, 3, 3,\u001b[0m\n",
       "\u001b[0;34m     4, 4, 4, 4,\u001b[0m\n",
       "\u001b[0;34m     3, 3,\u001b[0m\n",
       "\u001b[0;34m     4, 4,\u001b[0m\n",
       "\u001b[0;34m     5, 5, 5, 5,\u001b[0m\n",
       "\u001b[0;34m     5, 5]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: The order of elements yielded by this transformation is\u001b[0m\n",
       "\u001b[0;34m    deterministic, as long as `map_func` is a pure function and\u001b[0m\n",
       "\u001b[0;34m    `deterministic=True`. If `map_func` contains any stateful operations, the\u001b[0m\n",
       "\u001b[0;34m    order in which that state is accessed is undefined.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Performance can often be improved by setting `num_parallel_calls` so that\u001b[0m\n",
       "\u001b[0;34m    `interleave` will use multiple threads to fetch elements. If determinism\u001b[0m\n",
       "\u001b[0;34m    isn't required, it can also improve performance to set\u001b[0m\n",
       "\u001b[0;34m    `deterministic=False`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> filenames = [\"/var/data/file1.txt\", \"/var/data/file2.txt\",\u001b[0m\n",
       "\u001b[0;34m    ...              \"/var/data/file3.txt\", \"/var/data/file4.txt\"]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(filenames)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.interleave(lambda x: tf.data.TFRecordDataset(x),\u001b[0m\n",
       "\u001b[0;34m    ...     cycle_length=4, num_parallel_calls=tf.data.AUTOTUNE,\u001b[0m\n",
       "\u001b[0;34m    ...     deterministic=False)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      map_func: A function that takes a dataset element and returns a\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Dataset`.\u001b[0m\n",
       "\u001b[0;34m      cycle_length: (Optional.) The number of input elements that will be\u001b[0m\n",
       "\u001b[0;34m        processed concurrently. If not set, the tf.data runtime decides what it\u001b[0m\n",
       "\u001b[0;34m        should be based on available CPU. If `num_parallel_calls` is set to\u001b[0m\n",
       "\u001b[0;34m        `tf.data.AUTOTUNE`, the `cycle_length` argument identifies\u001b[0m\n",
       "\u001b[0;34m        the maximum degree of parallelism.\u001b[0m\n",
       "\u001b[0;34m      block_length: (Optional.) The number of consecutive elements to produce\u001b[0m\n",
       "\u001b[0;34m        from each input element before cycling to another input element. If not\u001b[0m\n",
       "\u001b[0;34m        set, defaults to 1.\u001b[0m\n",
       "\u001b[0;34m      num_parallel_calls: (Optional.) If specified, the implementation creates a\u001b[0m\n",
       "\u001b[0;34m        threadpool, which is used to fetch inputs from cycle elements\u001b[0m\n",
       "\u001b[0;34m        asynchronously and in parallel. The default behavior is to fetch inputs\u001b[0m\n",
       "\u001b[0;34m        from cycle elements synchronously with no parallelism. If the value\u001b[0m\n",
       "\u001b[0;34m        `tf.data.AUTOTUNE` is used, then the number of parallel\u001b[0m\n",
       "\u001b[0;34m        calls is set dynamically based on available CPU.\u001b[0m\n",
       "\u001b[0;34m      deterministic: (Optional.) When `num_parallel_calls` is specified, if this\u001b[0m\n",
       "\u001b[0;34m        boolean is specified (`True` or `False`), it controls the order in which\u001b[0m\n",
       "\u001b[0;34m        the transformation produces elements. If set to `False`, the\u001b[0m\n",
       "\u001b[0;34m        transformation is allowed to yield elements out of order to trade\u001b[0m\n",
       "\u001b[0;34m        determinism for performance. If not specified, the\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Options.deterministic` option (`True` by default) controls the\u001b[0m\n",
       "\u001b[0;34m        behavior.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> interleave_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0minterleave_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0minterleave_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_interleave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmap_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcycle_length\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mblock_length\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                     \u001b[0mnum_parallel_calls\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdeterministic\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mfilter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpredicate\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Filters this dataset according to `predicate`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 2, 3])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.filter(lambda x: x < 3)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2]\u001b[0m\n",
       "\u001b[0;34m    >>> # `tf.math.equal(x, y)` is required for equality comparison\u001b[0m\n",
       "\u001b[0;34m    >>> def filter_fn(x):\u001b[0m\n",
       "\u001b[0;34m    ...   return tf.math.equal(x, 1)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.filter(filter_fn)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      predicate: A function mapping a dataset element to a boolean.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> filter_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mfilter_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mfilter_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_filter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpredicate\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mapply\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtransformation_func\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Applies a transformation function to this dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `apply` enables chaining of custom `Dataset` transformations, which are\u001b[0m\n",
       "\u001b[0;34m    represented as functions that take one `Dataset` argument and return a\u001b[0m\n",
       "\u001b[0;34m    transformed `Dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(100)\u001b[0m\n",
       "\u001b[0;34m    >>> def dataset_fn(ds):\u001b[0m\n",
       "\u001b[0;34m    ...   return ds.filter(lambda x: x < 5)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.apply(dataset_fn)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      transformation_func: A function that takes one `Dataset` argument and\u001b[0m\n",
       "\u001b[0;34m        returns a `Dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtransformation_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdata_types\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mDatasetV2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34m`transformation_func` must return a `tf.data.Dataset` object. \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34mGot \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mdataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_input_datasets\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m]\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mdataset\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mwindow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msize\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mshift\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstride\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a dataset of \"windows\".\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Each \"window\" is a dataset that contains a subset of elements of the\u001b[0m\n",
       "\u001b[0;34m    input dataset. These are finite datasets of size `size` (or possibly fewer\u001b[0m\n",
       "\u001b[0;34m    if there are not enough input elements to fill the window and\u001b[0m\n",
       "\u001b[0;34m    `drop_remainder` evaluates to `False`).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(7).window(3)\u001b[0m\n",
       "\u001b[0;34m    >>> for window in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(window)\u001b[0m\n",
       "\u001b[0;34m    <...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)>\u001b[0m\n",
       "\u001b[0;34m    <...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)>\u001b[0m\n",
       "\u001b[0;34m    <...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int64, name=None)>\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Since windows are datasets, they can be iterated over:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> for window in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(list(window.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2]\u001b[0m\n",
       "\u001b[0;34m    [3, 4, 5]\u001b[0m\n",
       "\u001b[0;34m    [6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Shift\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `shift` argument determines the number of input elements to shift\u001b[0m\n",
       "\u001b[0;34m    between the start of each window. If windows and elements are both numbered\u001b[0m\n",
       "\u001b[0;34m    starting at 0, the first element in window `k` will be element `k * shift`\u001b[0m\n",
       "\u001b[0;34m    of the input dataset. In particular, the first element of the first window\u001b[0m\n",
       "\u001b[0;34m    will always be the first element of the input dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(7).window(3, shift=1,\u001b[0m\n",
       "\u001b[0;34m    ...                                           drop_remainder=True)\u001b[0m\n",
       "\u001b[0;34m    >>> for window in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(list(window.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2]\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3]\u001b[0m\n",
       "\u001b[0;34m    [2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m    [3, 4, 5]\u001b[0m\n",
       "\u001b[0;34m    [4, 5, 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Stride\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `stride` argument determines the stride between input elements within a\u001b[0m\n",
       "\u001b[0;34m    window.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(7).window(3, shift=1, stride=2,\u001b[0m\n",
       "\u001b[0;34m    ...                                           drop_remainder=True)\u001b[0m\n",
       "\u001b[0;34m    >>> for window in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(list(window.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    [0, 2, 4]\u001b[0m\n",
       "\u001b[0;34m    [1, 3, 5]\u001b[0m\n",
       "\u001b[0;34m    [2, 4, 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Nested elements\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    When the `window` transformation is applied to a dataset whos elements are\u001b[0m\n",
       "\u001b[0;34m    nested structures, it produces a dataset where the elements have the same\u001b[0m\n",
       "\u001b[0;34m    nested structure but each leaf is replaced by a window. In other words,\u001b[0m\n",
       "\u001b[0;34m    the nesting is applied outside of the windows as opposed inside of them.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The type signature is:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    def window(\u001b[0m\n",
       "\u001b[0;34m        self: Dataset[Nest[T]], ...\u001b[0m\n",
       "\u001b[0;34m    ) -> Dataset[Nest[Dataset[T]]]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Applying `window` to a `Dataset` of tuples gives a tuple of windows:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(([1, 2, 3, 4, 5],\u001b[0m\n",
       "\u001b[0;34m    ...                                               [6, 7, 8, 9, 10]))\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.window(2)\u001b[0m\n",
       "\u001b[0;34m    >>> windows = next(iter(dataset))\u001b[0m\n",
       "\u001b[0;34m    >>> windows\u001b[0m\n",
       "\u001b[0;34m    (<...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int32, name=None)>,\u001b[0m\n",
       "\u001b[0;34m     <...Dataset element_spec=TensorSpec(shape=(), dtype=tf.int32, name=None)>)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> def to_numpy(ds):\u001b[0m\n",
       "\u001b[0;34m    ...   return list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> for windows in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(to_numpy(windows[0]), to_numpy(windows[1]))\u001b[0m\n",
       "\u001b[0;34m    [1, 2] [6, 7]\u001b[0m\n",
       "\u001b[0;34m    [3, 4] [8, 9]\u001b[0m\n",
       "\u001b[0;34m    [5] [10]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Applying `window` to a `Dataset` of dictionaries gives a dictionary of\u001b[0m\n",
       "\u001b[0;34m    `Datasets`:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices({'a': [1, 2, 3],\u001b[0m\n",
       "\u001b[0;34m    ...                                               'b': [4, 5, 6],\u001b[0m\n",
       "\u001b[0;34m    ...                                               'c': [7, 8, 9]})\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.window(2)\u001b[0m\n",
       "\u001b[0;34m    >>> def to_numpy(ds):\u001b[0m\n",
       "\u001b[0;34m    ...   return list(ds.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>>\u001b[0m\n",
       "\u001b[0;34m    >>> for windows in dataset:\u001b[0m\n",
       "\u001b[0;34m    ...   print(tf.nest.map_structure(to_numpy, windows))\u001b[0m\n",
       "\u001b[0;34m    {'a': [1, 2], 'b': [4, 5], 'c': [7, 8]}\u001b[0m\n",
       "\u001b[0;34m    {'a': [3], 'b': [6], 'c': [9]}\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Flatten a dataset of windows\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The `Dataset.flat_map` and `Dataset.interleave` methods can be used to\u001b[0m\n",
       "\u001b[0;34m    flatten a dataset of windows into a single dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The argument to `flat_map` is a function that takes an element from the\u001b[0m\n",
       "\u001b[0;34m    dataset and returns a `Dataset`. `flat_map` chains together the resulting\u001b[0m\n",
       "\u001b[0;34m    datasets sequentially.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, to turn each window into a dense tensor:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(7).window(3, shift=1,\u001b[0m\n",
       "\u001b[0;34m    ...                                           drop_remainder=True)\u001b[0m\n",
       "\u001b[0;34m    >>> batched = dataset.flat_map(lambda x:x.batch(3))\u001b[0m\n",
       "\u001b[0;34m    >>> for batch in batched:\u001b[0m\n",
       "\u001b[0;34m    ...   print(batch.numpy())\u001b[0m\n",
       "\u001b[0;34m    [0 1 2]\u001b[0m\n",
       "\u001b[0;34m    [1 2 3]\u001b[0m\n",
       "\u001b[0;34m    [2 3 4]\u001b[0m\n",
       "\u001b[0;34m    [3 4 5]\u001b[0m\n",
       "\u001b[0;34m    [4 5 6]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      size: A `tf.int64` scalar `tf.Tensor`, representing the number of elements\u001b[0m\n",
       "\u001b[0;34m        of the input dataset to combine into a window. Must be positive.\u001b[0m\n",
       "\u001b[0;34m      shift: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\u001b[0m\n",
       "\u001b[0;34m        number of input elements by which the window moves in each iteration.\u001b[0m\n",
       "\u001b[0;34m        Defaults to `size`. Must be positive.\u001b[0m\n",
       "\u001b[0;34m      stride: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the\u001b[0m\n",
       "\u001b[0;34m        stride of the input elements in the sliding window. Must be positive.\u001b[0m\n",
       "\u001b[0;34m        The default value of 1 means \"retain every input element\".\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last windows should be dropped if their size is smaller than\u001b[0m\n",
       "\u001b[0;34m        `size`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> window_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mwindow_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mwindow_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_window\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msize\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mshift\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstride\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mreduce\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_state\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreduce_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Reduces the input dataset to a single element.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The transformation calls `reduce_func` successively on every element of\u001b[0m\n",
       "\u001b[0;34m    the input dataset until the dataset is exhausted, aggregating information in\u001b[0m\n",
       "\u001b[0;34m    its internal state. The `initial_state` argument is used for the initial\u001b[0m\n",
       "\u001b[0;34m    state and the final state is returned as the result.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, _: x + 1).numpy()\u001b[0m\n",
       "\u001b[0;34m    5\u001b[0m\n",
       "\u001b[0;34m    >>> tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, y: x + y).numpy()\u001b[0m\n",
       "\u001b[0;34m    10\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      initial_state: An element representing the initial state of the\u001b[0m\n",
       "\u001b[0;34m        transformation.\u001b[0m\n",
       "\u001b[0;34m      reduce_func: A function that maps `(old_state, input_element)` to\u001b[0m\n",
       "\u001b[0;34m        `new_state`. It must take two arguments and return a new element\u001b[0m\n",
       "\u001b[0;34m        The structure of `new_state` must match the structure of\u001b[0m\n",
       "\u001b[0;34m        `initial_state`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A dataset element corresponding to the final state of the transformation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mwith\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname_scope\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"initial_state\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minitial_state\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mnormalize_element\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitial_state\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mstate_structure\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mtype_spec_from_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitial_state\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Iteratively rerun the reduce function until reaching a fixed point on\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# `state_structure`.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mneed_to_rerun\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mwhile\u001b[0m \u001b[0mneed_to_rerun\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mwrapped_func\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstructured_function\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mStructuredFunctionWrapper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mreduce_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m\"reduce()\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0minput_structure\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_structure\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0madd_to_graph\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Extract and validate class information from the returned values.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_classes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_classes\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mstate_classes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_to_legacy_output_classes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstate_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfor\u001b[0m \u001b[0mnew_state_class\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstate_class\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutput_classes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_classes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0missubclass\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnew_state_class\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstate_class\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34mThe element classes for the new state must match the initial \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34mstate. Expected \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mstate_classes\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m but got \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_classes\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Extract and validate type information from the returned values.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_types\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_types\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mstate_types\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_to_legacy_output_types\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstate_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfor\u001b[0m \u001b[0mnew_state_type\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstate_type\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutput_types\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_types\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mnew_state_type\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mstate_type\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34mThe element types for the new state must match the initial \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34mstate. Expected \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mstate_types\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m but got \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_types\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# Extract shape information from the returned values.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0moutput_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_shapes\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mstate_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mcomponent_spec\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_to_legacy_output_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstate_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mflat_state_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_shapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mflat_new_state_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0moutput_shapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mweakened_state_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0moriginal\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmost_specific_compatible_shape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnew\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mfor\u001b[0m \u001b[0moriginal\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnew\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mflat_state_shapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mflat_new_state_shapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mneed_to_rerun\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfor\u001b[0m \u001b[0moriginal_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mweakened_shape\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mzip\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mflat_state_shapes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                                \u001b[0mweakened_state_shapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0moriginal_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndims\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mweakened_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndims\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32mor\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0moriginal_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mas_list\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0mweakened_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mas_list\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mneed_to_rerun\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mbreak\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mneed_to_rerun\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# TODO(b/110122868): Support a \"most specific compatible structure\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# method for combining structures, to avoid using legacy structures\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# here.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mstate_structure\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvert_legacy_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mstate_types\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpack_sequence_as\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_shapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mweakened_state_shapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mstate_classes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mreduce_func\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwrapped_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfunction\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mreduce_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd_to_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_default_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mdataset\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_apply_debug_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mmetadata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdataset_metadata_pb2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mMetadata\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmetadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_validate_and_encode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfrom_compatible_tensor_list\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mstate_structure\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreduce_dataset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mdataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mto_tensor_list\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_structure\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_state\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mreduce_func\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcaptured_inputs\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mf\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mreduce_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0moutput_shapes\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_flat_tensor_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0moutput_types\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_flat_tensor_types\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstate_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmetadata\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmetadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSerializeToString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mget_single_element\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns the single element of the `dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The function enables you to use a `tf.data.Dataset` in a stateless\u001b[0m\n",
       "\u001b[0;34m    \"tensor-in tensor-out\" expression, without creating an iterator.\u001b[0m\n",
       "\u001b[0;34m    This facilitates the ease of data transformation on tensors using the\u001b[0m\n",
       "\u001b[0;34m    optimized `tf.data.Dataset` abstraction on top of them.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, lets consider a `preprocessing_fn` which would take as an\u001b[0m\n",
       "\u001b[0;34m    input the raw features and returns the processed feature along with\u001b[0m\n",
       "\u001b[0;34m    it's label.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    def preprocessing_fn(raw_feature):\u001b[0m\n",
       "\u001b[0;34m      # ... the raw_feature is preprocessed as per the use-case\u001b[0m\n",
       "\u001b[0;34m      return feature\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    raw_features = ...  # input batch of BATCH_SIZE elements.\u001b[0m\n",
       "\u001b[0;34m    dataset = (tf.data.Dataset.from_tensor_slices(raw_features)\u001b[0m\n",
       "\u001b[0;34m              .map(preprocessing_fn, num_parallel_calls=BATCH_SIZE)\u001b[0m\n",
       "\u001b[0;34m              .batch(BATCH_SIZE))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    processed_features = dataset.get_single_element()\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    In the above example, the `raw_features` tensor of length=BATCH_SIZE\u001b[0m\n",
       "\u001b[0;34m    was converted to a `tf.data.Dataset`. Next, each of the `raw_feature` was\u001b[0m\n",
       "\u001b[0;34m    mapped using the `preprocessing_fn` and the processed features were\u001b[0m\n",
       "\u001b[0;34m    grouped into a single batch. The final `dataset` contains only one element\u001b[0m\n",
       "\u001b[0;34m    which is a batch of all the processed features.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    NOTE: The `dataset` should contain only one element.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Now, instead of creating an iterator for the `dataset` and retrieving the\u001b[0m\n",
       "\u001b[0;34m    batch of features, the `tf.data.get_single_element()` function is used\u001b[0m\n",
       "\u001b[0;34m    to skip the iterator creation process and directly output the batch of\u001b[0m\n",
       "\u001b[0;34m    features.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This can be particularly useful when your tensor transformations are\u001b[0m\n",
       "\u001b[0;34m    expressed as `tf.data.Dataset` operations, and you want to use those\u001b[0m\n",
       "\u001b[0;34m    transformations while serving your model.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    #### Keras\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    model = ... # A pre-built or custom model\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    class PreprocessingModel(tf.keras.Model):\u001b[0m\n",
       "\u001b[0;34m      def __init__(self, model):\u001b[0m\n",
       "\u001b[0;34m        super().__init__(self)\u001b[0m\n",
       "\u001b[0;34m        self.model = model\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m      @tf.function(input_signature=[...])\u001b[0m\n",
       "\u001b[0;34m      def serving_fn(self, data):\u001b[0m\n",
       "\u001b[0;34m        ds = tf.data.Dataset.from_tensor_slices(data)\u001b[0m\n",
       "\u001b[0;34m        ds = ds.map(preprocessing_fn, num_parallel_calls=BATCH_SIZE)\u001b[0m\n",
       "\u001b[0;34m        ds = ds.batch(batch_size=BATCH_SIZE)\u001b[0m\n",
       "\u001b[0;34m        return tf.argmax(self.model(ds.get_single_element()), axis=-1)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    preprocessing_model = PreprocessingModel(model)\u001b[0m\n",
       "\u001b[0;34m    your_exported_model_dir = ... # save the model to this path.\u001b[0m\n",
       "\u001b[0;34m    tf.saved_model.save(preprocessing_model, your_exported_model_dir,\u001b[0m\n",
       "\u001b[0;34m                  signatures={'serving_default': preprocessing_model.serving_fn}\u001b[0m\n",
       "\u001b[0;34m                  )\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A nested structure of `tf.Tensor` objects, corresponding to the single\u001b[0m\n",
       "\u001b[0;34m      element of `dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      InvalidArgumentError: (at runtime) if `dataset` does not contain exactly\u001b[0m\n",
       "\u001b[0;34m        one element.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mmetadata\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdataset_metadata_pb2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mMetadata\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mmetadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_validate_and_encode\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mstructure\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfrom_compatible_tensor_list\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0melement_spec\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_to_single_element\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmetadata\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmetadata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mSerializeToString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m**\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_flat_structure\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0munbatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Splits elements of a dataset into multiple elements.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, if elements of the dataset are shaped `[B, a0, a1, ...]`,\u001b[0m\n",
       "\u001b[0;34m    where `B` may vary for each input element, then for each element in the\u001b[0m\n",
       "\u001b[0;34m    dataset, the unbatched dataset will contain `B` consecutive elements\u001b[0m\n",
       "\u001b[0;34m    of shape `[a0, a1, ...]`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> elements = [ [1, 2, 3], [1, 2], [1, 2, 3, 4] ]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(lambda: elements, tf.int64)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.unbatch()\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 3, 1, 2, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: `unbatch` requires a data copy to slice up the batched tensor into\u001b[0m\n",
       "\u001b[0;34m    smaller, unbatched tensors. When optimizing performance, try to avoid\u001b[0m\n",
       "\u001b[0;34m    unnecessary usage of `unbatch`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> unbatch_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0munbatch_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0munbatch_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_unbatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mwith_options\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns a new `tf.data.Dataset` with the given options set.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The options are \"global\" in the sense they apply to the entire dataset.\u001b[0m\n",
       "\u001b[0;34m    If options are set multiple times, they are merged as long as different\u001b[0m\n",
       "\u001b[0;34m    options do not use different non-default values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds = tf.data.Dataset.range(5)\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.interleave(lambda x: tf.data.Dataset.range(5),\u001b[0m\n",
       "\u001b[0;34m    ...                    cycle_length=3,\u001b[0m\n",
       "\u001b[0;34m    ...                    num_parallel_calls=3)\u001b[0m\n",
       "\u001b[0;34m    >>> options = tf.data.Options()\u001b[0m\n",
       "\u001b[0;34m    >>> # This will make the interleave order non-deterministic.\u001b[0m\n",
       "\u001b[0;34m    >>> options.deterministic = False\u001b[0m\n",
       "\u001b[0;34m    >>> ds = ds.with_options(options)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      options: A `tf.data.Options` that identifies the options the use.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError: when an option is set more than once to a non-default value\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0m_OptionsDataset\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mcardinality\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Returns the cardinality of the dataset, if known.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `cardinality` may return `tf.data.INFINITE_CARDINALITY` if the dataset\u001b[0m\n",
       "\u001b[0;34m    contains an infinite number of elements or `tf.data.UNKNOWN_CARDINALITY` if\u001b[0m\n",
       "\u001b[0;34m    the analysis fails to determine the number of elements in the dataset\u001b[0m\n",
       "\u001b[0;34m    (e.g. when the dataset source is a file).\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(42)\u001b[0m\n",
       "\u001b[0;34m    >>> print(dataset.cardinality().numpy())\u001b[0m\n",
       "\u001b[0;34m    42\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.repeat()\u001b[0m\n",
       "\u001b[0;34m    >>> cardinality = dataset.cardinality()\u001b[0m\n",
       "\u001b[0;34m    >>> print((cardinality == tf.data.INFINITE_CARDINALITY).numpy())\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.filter(lambda x: True)\u001b[0m\n",
       "\u001b[0;34m    >>> cardinality = dataset.cardinality()\u001b[0m\n",
       "\u001b[0;34m    >>> print((cardinality == tf.data.UNKNOWN_CARDINALITY).numpy())\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A scalar `tf.int64` `Tensor` representing the cardinality of the dataset.\u001b[0m\n",
       "\u001b[0;34m      If the cardinality is infinite or unknown, `cardinality` returns the\u001b[0m\n",
       "\u001b[0;34m      named constants `tf.data.INFINITE_CARDINALITY` and\u001b[0m\n",
       "\u001b[0;34m      `tf.data.UNKNOWN_CARDINALITY` respectively.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mgen_dataset_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdataset_cardinality\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_variant_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mgroup_by_window\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mkey_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mreduce_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mwindow_size\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mwindow_size_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Groups windows of elements by key and reduces them.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This transformation maps each consecutive element in a dataset to a key\u001b[0m\n",
       "\u001b[0;34m    using `key_func` and groups the elements by key. It then applies\u001b[0m\n",
       "\u001b[0;34m    `reduce_func` to at most `window_size_func(key)` elements matching the same\u001b[0m\n",
       "\u001b[0;34m    key. All except the final window for each key will contain\u001b[0m\n",
       "\u001b[0;34m    `window_size_func(key)` elements; the final window may be smaller.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    You may provide either a constant `window_size` or a window size determined\u001b[0m\n",
       "\u001b[0;34m    by the key through `window_size_func`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> window_size = 5\u001b[0m\n",
       "\u001b[0;34m    >>> key_func = lambda x: x%2\u001b[0m\n",
       "\u001b[0;34m    >>> reduce_func = lambda key, dataset: dataset.batch(window_size)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.group_by_window(\u001b[0m\n",
       "\u001b[0;34m    ...           key_func=key_func,\u001b[0m\n",
       "\u001b[0;34m    ...           reduce_func=reduce_func,\u001b[0m\n",
       "\u001b[0;34m    ...           window_size=window_size)\u001b[0m\n",
       "\u001b[0;34m    >>> for elem in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(elem)\u001b[0m\n",
       "\u001b[0;34m    [0 2 4 6 8]\u001b[0m\n",
       "\u001b[0;34m    [1 3 5 7 9]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      key_func: A function mapping a nested structure of tensors (having shapes\u001b[0m\n",
       "\u001b[0;34m        and types defined by `self.output_shapes` and `self.output_types`) to a\u001b[0m\n",
       "\u001b[0;34m        scalar `tf.int64` tensor.\u001b[0m\n",
       "\u001b[0;34m      reduce_func: A function mapping a key and a dataset of up to `window_size`\u001b[0m\n",
       "\u001b[0;34m        consecutive elements matching that key to another dataset.\u001b[0m\n",
       "\u001b[0;34m      window_size: A `tf.int64` scalar `tf.Tensor`, representing the number of\u001b[0m\n",
       "\u001b[0;34m        consecutive elements matching the same key to combine in a single batch,\u001b[0m\n",
       "\u001b[0;34m        which will be passed to `reduce_func`. Mutually exclusive with\u001b[0m\n",
       "\u001b[0;34m        `window_size_func`.\u001b[0m\n",
       "\u001b[0;34m      window_size_func: A function mapping a key to a `tf.int64` scalar\u001b[0m\n",
       "\u001b[0;34m        `tf.Tensor`, representing the number of consecutive elements matching\u001b[0m\n",
       "\u001b[0;34m        the same key to combine in a single batch, which will be passed to\u001b[0m\n",
       "\u001b[0;34m        `reduce_func`. Mutually exclusive with `window_size`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError: if neither or both of {`window_size`, `window_size_func`} are\u001b[0m\n",
       "\u001b[0;34m        passed.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> group_by_window_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mgroup_by_window_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mgroup_by_window_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_group_by_window\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mkey_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreduce_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mwindow_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mwindow_size_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mbucket_by_sequence_length\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0melement_length_func\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbucket_boundaries\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbucket_batch_sizes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpadded_shapes\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpadding_values\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpad_to_bucket_boundary\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mno_padding\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"A transformation that buckets elements in a `Dataset` by length.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Elements of the `Dataset` are grouped together by length and then are padded\u001b[0m\n",
       "\u001b[0;34m    and batched.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This is useful for sequence tasks in which the elements have variable\u001b[0m\n",
       "\u001b[0;34m    length. Grouping together elements that have similar lengths reduces the\u001b[0m\n",
       "\u001b[0;34m    total fraction of padding in a batch which increases training step\u001b[0m\n",
       "\u001b[0;34m    efficiency.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Below is an example to bucketize the input data to the 3 buckets\u001b[0m\n",
       "\u001b[0;34m    \"[0, 3), [3, 5), [5, inf)\" based on sequence length, with batch size 2.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> elements = [\u001b[0m\n",
       "\u001b[0;34m    ...   [0], [1, 2, 3, 4], [5, 6, 7],\u001b[0m\n",
       "\u001b[0;34m    ...   [7, 8, 9, 10, 11], [13, 14, 15, 16, 19, 20], [21, 22]]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_generator(\u001b[0m\n",
       "\u001b[0;34m    ...     lambda: elements, tf.int64, output_shapes=[None])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.bucket_by_sequence_length(\u001b[0m\n",
       "\u001b[0;34m    ...         element_length_func=lambda elem: tf.shape(elem)[0],\u001b[0m\n",
       "\u001b[0;34m    ...         bucket_boundaries=[3, 5],\u001b[0m\n",
       "\u001b[0;34m    ...         bucket_batch_sizes=[2, 2, 2])\u001b[0m\n",
       "\u001b[0;34m    >>> for elem in dataset.as_numpy_iterator():\u001b[0m\n",
       "\u001b[0;34m    ...   print(elem)\u001b[0m\n",
       "\u001b[0;34m    [[1 2 3 4]\u001b[0m\n",
       "\u001b[0;34m    [5 6 7 0]]\u001b[0m\n",
       "\u001b[0;34m    [[ 7  8  9 10 11  0]\u001b[0m\n",
       "\u001b[0;34m    [13 14 15 16 19 20]]\u001b[0m\n",
       "\u001b[0;34m    [[ 0  0]\u001b[0m\n",
       "\u001b[0;34m    [21 22]]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      element_length_func: function from element in `Dataset` to `tf.int32`,\u001b[0m\n",
       "\u001b[0;34m        determines the length of the element, which will determine the bucket it\u001b[0m\n",
       "\u001b[0;34m        goes into.\u001b[0m\n",
       "\u001b[0;34m      bucket_boundaries: `list<int>`, upper length boundaries of the buckets.\u001b[0m\n",
       "\u001b[0;34m      bucket_batch_sizes: `list<int>`, batch size per bucket. Length should be\u001b[0m\n",
       "\u001b[0;34m        `len(bucket_boundaries) + 1`.\u001b[0m\n",
       "\u001b[0;34m      padded_shapes: Nested structure of `tf.TensorShape` to pass to\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Dataset.padded_batch`. If not provided, will use\u001b[0m\n",
       "\u001b[0;34m        `dataset.output_shapes`, which will result in variable length dimensions\u001b[0m\n",
       "\u001b[0;34m        being padded out to the maximum length in each batch.\u001b[0m\n",
       "\u001b[0;34m      padding_values: Values to pad with, passed to\u001b[0m\n",
       "\u001b[0;34m        `tf.data.Dataset.padded_batch`. Defaults to padding with 0.\u001b[0m\n",
       "\u001b[0;34m      pad_to_bucket_boundary: bool, if `False`, will pad dimensions with unknown\u001b[0m\n",
       "\u001b[0;34m        size to maximum length in batch. If `True`, will pad dimensions with\u001b[0m\n",
       "\u001b[0;34m        unknown size to bucket boundary minus 1 (i.e., the maximum length in\u001b[0m\n",
       "\u001b[0;34m        each bucket), and caller must ensure that the source `Dataset` does not\u001b[0m\n",
       "\u001b[0;34m        contain any elements with length longer than `max(bucket_boundaries)`.\u001b[0m\n",
       "\u001b[0;34m      no_padding: `bool`, indicates whether to pad the batch features (features\u001b[0m\n",
       "\u001b[0;34m        need to be either of type `tf.sparse.SparseTensor` or of same shape).\u001b[0m\n",
       "\u001b[0;34m      drop_remainder: (Optional.) A `tf.bool` scalar `tf.Tensor`, representing\u001b[0m\n",
       "\u001b[0;34m        whether the last batch should be dropped in the case it has fewer than\u001b[0m\n",
       "\u001b[0;34m        `batch_size` elements; the default behavior is not to drop the smaller\u001b[0m\n",
       "\u001b[0;34m        batch.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      ValueError: if `len(bucket_batch_sizes) != len(bucket_boundaries) + 1`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_batch_sizes\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_boundaries\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34m`len(bucket_batch_sizes)` must equal `len(bucket_boundaries) + 1` \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34mbut `len(bucket_batch_sizes)=\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_batch_sizes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m` and \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34mf\"\u001b[0m\u001b[0;34m`len(bucket_boundaries)=\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_boundaries\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m`.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mbatch_sizes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconstant_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconstant\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_batch_sizes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0melement_to_bucket_id\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;34m\"\"\"Return int64 id of the length bucket for this element.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mseq_length\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0melement_length_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mboundaries\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_boundaries\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbuckets_min\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miinfo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint32\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmin\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mboundaries\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbuckets_max\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mboundaries\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0miinfo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint32\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmax\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mconditions_c\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlogical_and\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mless_equal\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbuckets_min\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseq_length\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mless\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mseq_length\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mbuckets_max\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbucket_id\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreduce_min\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwhere\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mconditions_c\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mbucket_id\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mwindow_size_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;31m# The window size is set to the batch size for this bucket\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mwindow_size\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mbatch_sizes\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mbucket_id\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mwindow_size\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mmake_padded_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnone_filler\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpadded\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mfor\u001b[0m \u001b[0mshape\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflatten\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshapes\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mshape\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtensor_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTensorShape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mshape\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mnone_filler\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0mtensor_shape\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdimension_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0md\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0md\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mfor\u001b[0m \u001b[0md\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mshape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mpadded\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mnest\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpack_sequence_as\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpadded\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mbatching_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_id\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mgrouped_dataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;34m\"\"\"Batch elements in dataset.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mbatch_size\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mwindow_size_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_id\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mno_padding\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mgrouped_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mnone_filler\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mpad_to_bucket_boundary\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0merr_msg\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\"When pad_to_bucket_boundary=True, elements must have \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                   \u001b[0;34m\"length < max(bucket_boundaries).\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mcheck\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcheck_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0massert_less\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mbucket_id\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mconstant_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconstant\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbucket_batch_sizes\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmessage\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0merr_msg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mwith\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcontrol_dependencies\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mcheck\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mboundaries\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconstant_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconstant\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0mbucket_boundaries\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mint64\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mbucket_boundary\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mboundaries\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mbucket_id\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mnone_filler\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mbucket_boundary\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minput_shapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mget_legacy_output_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgrouped_dataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mshapes\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmake_padded_shapes\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mpadded_shapes\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0minput_shapes\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnone_filler\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnone_filler\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mgrouped_dataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpadded_batch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mbatch_size\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mshapes\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mpadding_values\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mdrop_remainder\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdrop_remainder\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mgroup_by_window\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mkey_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0melement_to_bucket_id\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mreduce_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mbatching_fn\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mwindow_size_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mwindow_size_fn\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mrandom\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrerandomize_each_iteration\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a `Dataset` of pseudorandom values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The dataset generates a sequence of uniformly distributed integer values.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `rerandomize_each_iteration` controls whether the sequence of random number\u001b[0m\n",
       "\u001b[0;34m    generated should be re-randomized for each epoch. The default value is False\u001b[0m\n",
       "\u001b[0;34m    where the dataset generates the same sequence of random numbers for each\u001b[0m\n",
       "\u001b[0;34m    epoch.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds1 = tf.data.Dataset.random(seed=4).take(10)\u001b[0m\n",
       "\u001b[0;34m    >>> ds2 = tf.data.Dataset.random(seed=4).take(10)\u001b[0m\n",
       "\u001b[0;34m    >>> print(list(ds1.as_numpy_iterator())==list(ds2.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds3 = tf.data.Dataset.random(seed=4).take(10)\u001b[0m\n",
       "\u001b[0;34m    >>> ds3_first_epoch = list(ds3.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>> ds3_second_epoch = list(ds3.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>> print(ds3_first_epoch == ds3_second_epoch)\u001b[0m\n",
       "\u001b[0;34m    True\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> ds4 = tf.data.Dataset.random(\u001b[0m\n",
       "\u001b[0;34m    ...     seed=4, rerandomize_each_iteration=True).take(10)\u001b[0m\n",
       "\u001b[0;34m    >>> ds4_first_epoch = list(ds4.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>> ds4_second_epoch = list(ds4.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    >>> print(ds4_first_epoch == ds4_second_epoch)\u001b[0m\n",
       "\u001b[0;34m    False\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      seed: (Optional) If specified, the dataset produces a deterministic\u001b[0m\n",
       "\u001b[0;34m        sequence of values.\u001b[0m\n",
       "\u001b[0;34m      rerandomize_each_iteration: (Optional) If set to False, the dataset\u001b[0m\n",
       "\u001b[0;34m      generates the same sequence of random numbers for each epoch. If set to\u001b[0m\n",
       "\u001b[0;34m      True, it generates a different deterministic sequence of random numbers\u001b[0m\n",
       "\u001b[0;34m      for each epoch. It is defaulted to False if left unspecified.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      Dataset: A `Dataset`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> random_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mrandom_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mrandom_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_random\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mseed\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mrerandomize_each_iteration\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mrerandomize_each_iteration\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0msnapshot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mcompression\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"AUTO\"\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mreader_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mshard_func\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"API to persist the output of the input dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The snapshot API allows users to transparently persist the output of their\u001b[0m\n",
       "\u001b[0;34m    preprocessing pipeline to disk, and materialize the pre-processed data on a\u001b[0m\n",
       "\u001b[0;34m    different training run.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This API enables repeated preprocessing steps to be consolidated, and allows\u001b[0m\n",
       "\u001b[0;34m    re-use of already processed data, trading off disk storage and network\u001b[0m\n",
       "\u001b[0;34m    bandwidth for freeing up more valuable CPU resources and accelerator compute\u001b[0m\n",
       "\u001b[0;34m    time.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    https://github.com/tensorflow/community/blob/master/rfcs/20200107-tf-data-snapshot.md\u001b[0m\n",
       "\u001b[0;34m    has detailed design documentation of this feature.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Users can specify various options to control the behavior of snapshot,\u001b[0m\n",
       "\u001b[0;34m    including how snapshots are read from and written to by passing in\u001b[0m\n",
       "\u001b[0;34m    user-defined functions to the `reader_func` and `shard_func` parameters.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `shard_func` is a user specified function that maps input elements to\u001b[0m\n",
       "\u001b[0;34m    snapshot shards.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Users may want to specify this function to control how snapshot files should\u001b[0m\n",
       "\u001b[0;34m    be written to disk. Below is an example of how a potential `shard_func`\u001b[0m\n",
       "\u001b[0;34m    could be written.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset = ...\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.enumerate()\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.snapshot(\"/path/to/snapshot/dir\",\u001b[0m\n",
       "\u001b[0;34m        shard_func=lambda x, y: x % NUM_SHARDS, ...)\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.map(lambda x, y: y)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    `reader_func` is a user specified function that accepts a single argument:\u001b[0m\n",
       "\u001b[0;34m    (1) a Dataset of Datasets, each representing a \"split\" of elements of the\u001b[0m\n",
       "\u001b[0;34m    original dataset. The cardinality of the input dataset matches the\u001b[0m\n",
       "\u001b[0;34m    number of the shards specified in the `shard_func` (see above). The function\u001b[0m\n",
       "\u001b[0;34m    should return a Dataset of elements of the original dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Users may want specify this function to control how snapshot files should be\u001b[0m\n",
       "\u001b[0;34m    read from disk, including the amount of shuffling and parallelism.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Here is an example of a standard reader function a user can define. This\u001b[0m\n",
       "\u001b[0;34m    function enables both dataset shuffling and parallel reading of datasets:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    def user_reader_func(datasets):\u001b[0m\n",
       "\u001b[0;34m      # shuffle the datasets splits\u001b[0m\n",
       "\u001b[0;34m      datasets = datasets.shuffle(NUM_CORES)\u001b[0m\n",
       "\u001b[0;34m      # read datasets in parallel and interleave their elements\u001b[0m\n",
       "\u001b[0;34m      return datasets.interleave(lambda x: x, num_parallel_calls=AUTOTUNE)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    dataset = dataset.snapshot(\"/path/to/snapshot/dir\",\u001b[0m\n",
       "\u001b[0;34m        reader_func=user_reader_func)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    By default, snapshot parallelizes reads by the number of cores available on\u001b[0m\n",
       "\u001b[0;34m    the system, but will not attempt to shuffle the data.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      path: Required. A directory to use for storing / loading the snapshot to /\u001b[0m\n",
       "\u001b[0;34m        from.\u001b[0m\n",
       "\u001b[0;34m      compression: Optional. The type of compression to apply to the snapshot\u001b[0m\n",
       "\u001b[0;34m        written to disk. Supported options are `GZIP`, `SNAPPY`, `AUTO` or None.\u001b[0m\n",
       "\u001b[0;34m        Defaults to `AUTO`, which attempts to pick an appropriate compression\u001b[0m\n",
       "\u001b[0;34m        algorithm for the dataset.\u001b[0m\n",
       "\u001b[0;34m      reader_func: Optional. A function to control how to read data from\u001b[0m\n",
       "\u001b[0;34m        snapshot shards.\u001b[0m\n",
       "\u001b[0;34m      shard_func: Optional. A function to control how to shard data when writing\u001b[0m\n",
       "\u001b[0;34m        a snapshot.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> snapshot_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0msnapshot_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0msnapshot_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_snapshot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpath\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcompression\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mreader_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mshard_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mscan\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_state\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mscan_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"A transformation that scans a function across an input dataset.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    This transformation is a stateful relative of `tf.data.Dataset.map`.\u001b[0m\n",
       "\u001b[0;34m    In addition to mapping `scan_func` across the elements of the input dataset,\u001b[0m\n",
       "\u001b[0;34m    `scan()` accumulates one or more state tensors, whose initial values are\u001b[0m\n",
       "\u001b[0;34m    `initial_state`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> initial_state = tf.constant(0, dtype=tf.int64)\u001b[0m\n",
       "\u001b[0;34m    >>> scan_func = lambda state, i: (state + i, state + i)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.scan(initial_state=initial_state, scan_func=scan_func)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      initial_state: A nested structure of tensors, representing the initial\u001b[0m\n",
       "\u001b[0;34m        state of the accumulator.\u001b[0m\n",
       "\u001b[0;34m      scan_func: A function that maps `(old_state, input_element)` to\u001b[0m\n",
       "\u001b[0;34m        `(new_state, output_element)`. It must take two arguments and return a\u001b[0m\n",
       "\u001b[0;34m        pair of nested structures of tensors. The `new_state` must match the\u001b[0m\n",
       "\u001b[0;34m        structure of `initial_state`.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# scan_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mscan_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mscan_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_scan\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_state\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mscan_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mtake_while\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpredicate\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"A transformation that stops dataset iteration based on a `predicate`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.range(10)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.take_while(lambda x: x < 5)\u001b[0m\n",
       "\u001b[0;34m    >>> list(dataset.as_numpy_iterator())\u001b[0m\n",
       "\u001b[0;34m    [0, 1, 2, 3, 4]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      predicate: A function that maps a nested structure of tensors (having\u001b[0m\n",
       "\u001b[0;34m        shapes and types defined by `self.output_shapes` and\u001b[0m\n",
       "\u001b[0;34m        `self.output_types`) to a scalar `tf.bool` tensor.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops -> take_while_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mtake_while_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mtake_while_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_take_while\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mpredicate\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0munique\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"A transformation that discards duplicate elements of a `Dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Use this transformation to produce a dataset that contains one instance of\u001b[0m\n",
       "\u001b[0;34m    each unique element in the input. For example:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices([1, 37, 2, 37, 2, 1])\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.unique()\u001b[0m\n",
       "\u001b[0;34m    >>> sorted(list(dataset.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    [1, 2, 37]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: This transformation only supports datasets which fit into memory\u001b[0m\n",
       "\u001b[0;34m    and have elements of either `tf.int32`, `tf.int64` or `tf.string` type.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency (dataset_ops -> unique_op ->\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0munique_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0munique_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_unique\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mrejection_resample\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mclass_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_dist\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Resamples elements to reach a target distribution.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Note: This implementation can reject **or repeat** elements in order to\u001b[0m\n",
       "\u001b[0;34m    reach the `target_dist`. So, in some cases, the output `Dataset` may be\u001b[0m\n",
       "\u001b[0;34m    larger than the input `Dataset`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> initial_dist = [0.6, 0.4]\u001b[0m\n",
       "\u001b[0;34m    >>> n = 1000\u001b[0m\n",
       "\u001b[0;34m    >>> elems = np.random.choice(len(initial_dist), size=n, p=initial_dist)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = tf.data.Dataset.from_tensor_slices(elems)\u001b[0m\n",
       "\u001b[0;34m    >>> zero, one = np.bincount(list(dataset.as_numpy_iterator())) / n\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Following from `initial_dist`, `zero` is ~0.6 and `one` is ~0.4.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    >>> target_dist = [0.5, 0.5]\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.rejection_resample(\u001b[0m\n",
       "\u001b[0;34m    ...    class_func=lambda x: x,\u001b[0m\n",
       "\u001b[0;34m    ...    target_dist=target_dist,\u001b[0m\n",
       "\u001b[0;34m    ...    initial_dist=initial_dist)\u001b[0m\n",
       "\u001b[0;34m    >>> dataset = dataset.map(lambda class_func_result, data: data)\u001b[0m\n",
       "\u001b[0;34m    >>> zero, one = np.bincount(list(dataset.as_numpy_iterator())) / n\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Following from `target_dist`, `zero` is ~0.5 and `one` is ~0.5.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      class_func: A function mapping an element of the input dataset to a scalar\u001b[0m\n",
       "\u001b[0;34m        `tf.int32` tensor. Values should be in `[0, num_classes)`.\u001b[0m\n",
       "\u001b[0;34m      target_dist: A floating point type tensor, shaped `[num_classes]`.\u001b[0m\n",
       "\u001b[0;34m      initial_dist: (Optional.)  A floating point type tensor, shaped\u001b[0m\n",
       "\u001b[0;34m        `[num_classes]`.  If not provided, the true class distribution is\u001b[0m\n",
       "\u001b[0;34m        estimated live in a streaming fashion.\u001b[0m\n",
       "\u001b[0;34m      seed: (Optional.) Python integer seed for the resampler.\u001b[0m\n",
       "\u001b[0;34m      name: (Optional.) A name for the tf.data operation.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# TODO(b/245793127): Consider switching back to the 'v1' implementation.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mtarget_dist_t\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvert_to_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtarget_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"target_dist\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mtarget_dist_t\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcast\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtarget_dist_t\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfloat32\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Get initial distribution.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0minitial_dist\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minitial_dist_t\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvert_to_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitial_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;34m\"initial_dist\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minitial_dist_t\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmath_ops\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcast\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitial_dist_t\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtypes\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfloat32\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0macceptance_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mprob_of_original\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0m_calculate_acceptance_probs_with_mixing\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minitial_dist_t\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                                                  \u001b[0mtarget_dist_t\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minitial_dist_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDatasetV2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfrom_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0minitial_dist_t\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrepeat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0macceptance_dist_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDatasetV2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfrom_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0macceptance_dist\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrepeat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mprob_of_original_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mDatasetV2\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfrom_tensors\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mprob_of_original\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mrepeat\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0minitial_dist_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_estimate_initial_dist_ds\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mtarget_dist_t\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mclass_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0macceptance_and_original_prob_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minitial_dist_ds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0minitial\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0m_calculate_acceptance_probs_with_mixing\u001b[0m\u001b[0;34m(\u001b[0m  \u001b[0;31m# pylint: disable=g-long-lambda\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m              \u001b[0minitial\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_dist_t\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0macceptance_dist_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0macceptance_and_original_prob_ds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0maccept_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0m_\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0maccept_prob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mprob_of_original_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0macceptance_and_original_prob_ds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;32mlambda\u001b[0m \u001b[0m_\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mprob_original\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mprob_original\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mfiltered_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_filter_ds\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0macceptance_dist_ds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minitial_dist_ds\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                             \u001b[0mclass_func\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mseed\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Prefetch filtered dataset for speed.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mfiltered_ds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfiltered_ds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mprefetch\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0mprob_original_static\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0m_get_prob_original_static\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0minitial_dist_t\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_dist_t\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mif\u001b[0m \u001b[0minitial_dist\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m \u001b[0;32melse\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0madd_class_value\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mclass_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mclass_func\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mif\u001b[0m \u001b[0mprob_original_static\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0madd_class_value\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melif\u001b[0m \u001b[0mprob_original_static\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mfiltered_ds\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0;32mreturn\u001b[0m \u001b[0mDataset\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msample_from_datasets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0;34m[\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0madd_class_value\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfiltered_ds\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mweights\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mprob_of_original_ds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0mprob\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mprob\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1.0\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mprob\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mseed\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m          \u001b[0mstop_on_empty_dataset\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0msample_from_datasets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdatasets\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mweights\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mseed\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mstop_on_empty_dataset\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mrerandomize_each_iteration\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Samples elements at random from the datasets in `datasets`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Creates a dataset by interleaving elements of `datasets` with `weight[i]`\u001b[0m\n",
       "\u001b[0;34m    probability of picking an element from dataset `i`. Sampling is done without\u001b[0m\n",
       "\u001b[0;34m    replacement. For example, suppose we have 2 datasets:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    dataset1 = tf.data.Dataset.range(0, 3)\u001b[0m\n",
       "\u001b[0;34m    dataset2 = tf.data.Dataset.range(100, 103)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Suppose that we sample from these 2 datasets with the following weights:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    sample_dataset = tf.data.Dataset.sample_from_datasets(\u001b[0m\n",
       "\u001b[0;34m        [dataset1, dataset2], weights=[0.5, 0.5])\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    One possible outcome of elements in sample_dataset is:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    print(list(sample_dataset.as_numpy_iterator()))\u001b[0m\n",
       "\u001b[0;34m    # [100, 0, 1, 101, 2, 102]\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      datasets: A non-empty list of `tf.data.Dataset` objects with compatible\u001b[0m\n",
       "\u001b[0;34m        structure.\u001b[0m\n",
       "\u001b[0;34m      weights: (Optional.) A list or Tensor of `len(datasets)` floating-point\u001b[0m\n",
       "\u001b[0;34m        values where `weights[i]` represents the probability to sample from\u001b[0m\n",
       "\u001b[0;34m        `datasets[i]`, or a `tf.data.Dataset` object where each element is such\u001b[0m\n",
       "\u001b[0;34m        a list. Defaults to a uniform distribution across `datasets`.\u001b[0m\n",
       "\u001b[0;34m      seed: (Optional.) A `tf.int64` scalar `tf.Tensor`, representing the random\u001b[0m\n",
       "\u001b[0;34m        seed that will be used to create the distribution. See\u001b[0m\n",
       "\u001b[0;34m        `tf.random.set_seed` for behavior.\u001b[0m\n",
       "\u001b[0;34m      stop_on_empty_dataset: If `True`, sampling stops if it encounters an empty\u001b[0m\n",
       "\u001b[0;34m        dataset. If `False`, it continues sampling and skips any empty datasets.\u001b[0m\n",
       "\u001b[0;34m        It is recommended to set it to `True`. Otherwise, the distribution of\u001b[0m\n",
       "\u001b[0;34m        samples starts off as the user intends, but may change as input datasets\u001b[0m\n",
       "\u001b[0;34m        become empty. This can be difficult to detect since the dataset starts\u001b[0m\n",
       "\u001b[0;34m        off looking correct. Default to `False` for backward compatibility.\u001b[0m\n",
       "\u001b[0;34m      rerandomize_each_iteration: An optional `bool`. The boolean argument\u001b[0m\n",
       "\u001b[0;34m      controls whether the sequence of random numbers used to determine which\u001b[0m\n",
       "\u001b[0;34m      dataset to sample from will be rerandomized each epoch. That is, it\u001b[0m\n",
       "\u001b[0;34m      determinies whether datasets will be sampled in the same order across\u001b[0m\n",
       "\u001b[0;34m      different epochs (the default behavior) or not.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A dataset that interleaves elements from `datasets` at random, according\u001b[0m\n",
       "\u001b[0;34m      to `weights` if provided, otherwise with uniform probability.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      TypeError: If the `datasets` or `weights` arguments have the wrong type.\u001b[0m\n",
       "\u001b[0;34m      ValueError:\u001b[0m\n",
       "\u001b[0;34m        - If `datasets` is empty, or\u001b[0m\n",
       "\u001b[0;34m        - If `weights` is specified and does not match the length of `datasets`.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# (dataset_ops -> sample_from_datasets_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0msample_from_datasets_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0msample_from_datasets_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_sample_from_datasets\u001b[0m\u001b[0;34m(\u001b[0m  \u001b[0;31m# pylint: disable=protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mdatasets\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mweights\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mseed\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mstop_on_empty_dataset\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mrerandomize_each_iteration\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;32mdef\u001b[0m \u001b[0mchoose_from_datasets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m      \u001b[0mdatasets\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mchoice_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstop_on_empty_dataset\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m  \u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;34m\"DatasetV2\"\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"Creates a dataset that deterministically chooses elements from `datasets`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    For example, given the following datasets:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    datasets = [tf.data.Dataset.from_tensors(\"foo\").repeat(),\u001b[0m\n",
       "\u001b[0;34m                tf.data.Dataset.from_tensors(\"bar\").repeat(),\u001b[0m\n",
       "\u001b[0;34m                tf.data.Dataset.from_tensors(\"baz\").repeat()]\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    # Define a dataset containing `[0, 1, 2, 0, 1, 2, 0, 1, 2]`.\u001b[0m\n",
       "\u001b[0;34m    choice_dataset = tf.data.Dataset.range(3).repeat(3)\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    result = tf.data.Dataset.choose_from_datasets(datasets, choice_dataset)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    The elements of `result` will be:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    \"foo\", \"bar\", \"baz\", \"foo\", \"bar\", \"baz\", \"foo\", \"bar\", \"baz\"\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Args:\u001b[0m\n",
       "\u001b[0;34m      datasets: A non-empty list of `tf.data.Dataset` objects with compatible\u001b[0m\n",
       "\u001b[0;34m        structure.\u001b[0m\n",
       "\u001b[0;34m      choice_dataset: A `tf.data.Dataset` of scalar `tf.int64` tensors between\u001b[0m\n",
       "\u001b[0;34m        `0` and `len(datasets) - 1`.\u001b[0m\n",
       "\u001b[0;34m      stop_on_empty_dataset: If `True`, selection stops if it encounters an\u001b[0m\n",
       "\u001b[0;34m        empty dataset. If `False`, it skips empty datasets. It is recommended to\u001b[0m\n",
       "\u001b[0;34m        set it to `True`. Otherwise, the selected elements start off as the user\u001b[0m\n",
       "\u001b[0;34m        intends, but may change as input datasets become empty. This can be\u001b[0m\n",
       "\u001b[0;34m        difficult to detect since the dataset starts off looking correct.\u001b[0m\n",
       "\u001b[0;34m        Defaults to `True`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Returns:\u001b[0m\n",
       "\u001b[0;34m      A new `Dataset` with the transformation applied as described above.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Raises:\u001b[0m\n",
       "\u001b[0;34m      TypeError: If `datasets` or `choice_dataset` has the wrong type.\u001b[0m\n",
       "\u001b[0;34m      ValueError: If `datasets` is empty.\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# Loaded lazily due to a circular dependency\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# (dataset_ops -> choose_from_datasets_op -> dataset_ops).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: disable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mfrom\u001b[0m \u001b[0mtensorflow\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpython\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mops\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mchoose_from_datasets_op\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mreturn\u001b[0m \u001b[0mchoose_from_datasets_op\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_choose_from_datasets\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mdatasets\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mchoice_dataset\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstop_on_empty_dataset\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;31m# pylint: enable=g-import-not-at-top,protected-access\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
       "\u001b[0;31mFile:\u001b[0m           ~/.local/lib/python3.12/site-packages/tensorflow/python/data/ops/dataset_ops.py\n",
       "\u001b[0;31mType:\u001b[0m           ABCMeta\n",
       "\u001b[0;31mSubclasses:\u001b[0m     DatasetV1, DatasetSource, UnaryDataset, _VariantDataset, TFRecordDatasetV2, _PerDeviceGenerator, _ReincarnatedPerDeviceGenerator, _ZipDataset"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "tf.data.Dataset??"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 231,
   "id": "840438d3-ea0e-4f8a-8bbd-8b165cc1fcaa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Found 168 files belonging to 2 classes.\n"
     ]
    }
   ],
   "source": [
    "data = tf.keras.utils.image_dataset_from_directory(\"data\", batch_size=40, image_size=(128, 128))\n",
    "data = data.map(lambda x, y: (x/255, y))\n",
    "data_iterator = data.as_numpy_iterator()\n",
    "batch = data_iterator.next()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 317,
   "id": "44e22499-b484-430c-85ed-d8d4c6897785",
   "metadata": {},
   "outputs": [],
   "source": [
    "#declaring training, validation & testing data size\n",
    "\n",
    "training_size = int(len(data)*.7)\n",
    "valid_size = int(len(data)* .2) + 2\n",
    "testing_size = int(len(data)*.1) + 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 318,
   "id": "bcc90ae7-4694-4519-9c2c-6ecb03794777",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(3, 3, 1)"
      ]
     },
     "execution_count": 318,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "training_size, valid_size, testing_size"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 319,
   "id": "c69cca7e-1aec-4f31-80e6-2225330f020e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#declaring training, validation & testing data\n",
    "\n",
    "training_data = data.take(training_size)\n",
    "valid_data = data.skip(training_size).take(valid_size)\n",
    "testing_data = data.skip(training_size + valid_size).take(testing_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 320,
   "id": "e307149a-19d3-4caf-bbef-3e9d330fa586",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[[[9.72549021e-01 9.49019611e-01 9.01960790e-01]\n",
      "   [9.68627453e-01 9.45098042e-01 8.98039222e-01]\n",
      "   [9.68627453e-01 9.45098042e-01 8.98039222e-01]\n",
      "   ...\n",
      "   [4.23763394e-01 2.47966811e-01 2.01306269e-01]\n",
      "   [3.22454602e-01 2.17527017e-01 1.86213240e-01]\n",
      "   [1.98789835e-01 1.49017930e-01 1.41650513e-01]]\n",
      "\n",
      "  [[9.72549021e-01 9.49019611e-01 9.01960790e-01]\n",
      "   [9.66191769e-01 9.42662358e-01 8.95603538e-01]\n",
      "   [9.61734056e-01 9.38204646e-01 8.91145825e-01]\n",
      "   ...\n",
      "   [3.27609658e-01 2.14006737e-01 1.70698225e-01]\n",
      "   [2.38556981e-01 1.72372729e-01 1.41536340e-01]\n",
      "   [1.51672244e-01 1.27369359e-01 1.13248102e-01]]\n",
      "\n",
      "  [[9.71737146e-01 9.48207736e-01 9.01148915e-01]\n",
      "   [9.64705884e-01 9.41176474e-01 8.94117653e-01]\n",
      "   [9.60912466e-01 9.37383056e-01 8.90324235e-01]\n",
      "   ...\n",
      "   [2.40456492e-01 1.81209669e-01 1.53207213e-01]\n",
      "   [1.79077506e-01 1.38912067e-01 1.21188417e-01]\n",
      "   [1.42979875e-01 1.23809338e-01 1.07904412e-01]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[7.19538212e-01 7.69041061e-01 7.06595361e-01]\n",
      "   [5.43815076e-01 7.32124209e-01 6.89158261e-01]\n",
      "   [2.78889984e-01 6.28759265e-01 6.34482801e-01]\n",
      "   ...\n",
      "   [6.87744170e-02 7.31095821e-02 8.08148533e-02]\n",
      "   [6.85312569e-01 6.51504338e-01 6.34868324e-01]\n",
      "   [1.92435712e-01 1.80233702e-01 1.48843080e-01]]\n",
      "\n",
      "  [[7.63751090e-01 7.73792565e-01 7.21183360e-01]\n",
      "   [7.02315032e-01 8.01448941e-01 7.48799026e-01]\n",
      "   [9.47276428e-02 4.53528792e-01 4.76675242e-01]\n",
      "   ...\n",
      "   [4.93581742e-02 6.51489273e-02 6.93462268e-02]\n",
      "   [6.29487514e-01 5.97272694e-01 5.88479817e-01]\n",
      "   [4.00173426e-01 3.89039278e-01 3.83253872e-01]]\n",
      "\n",
      "  [[7.17171371e-01 7.33669519e-01 6.83302701e-01]\n",
      "   [7.32633948e-01 7.69773841e-01 7.06551373e-01]\n",
      "   [1.56668872e-02 3.85427803e-01 4.09061700e-01]\n",
      "   ...\n",
      "   [2.56922096e-02 3.00273821e-02 3.80083881e-02]\n",
      "   [4.56401020e-01 4.40714747e-01 4.28950042e-01]\n",
      "   [5.52748740e-02 6.80497736e-02 8.06263611e-02]]]\n",
      "\n",
      "\n",
      " [[[9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.62844193e-01 9.62844193e-01 9.62844193e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   ...\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]]\n",
      "\n",
      "  [[9.61167276e-01 9.61167276e-01 9.61167276e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   ...\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]]\n",
      "\n",
      "  [[9.61167276e-01 9.61167276e-01 9.61167276e-01]\n",
      "   [9.64619219e-01 9.64619219e-01 9.64619219e-01]\n",
      "   [9.64646041e-01 9.64646041e-01 9.64646041e-01]\n",
      "   ...\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[9.64595318e-01 9.64595318e-01 9.64595318e-01]\n",
      "   [9.64619219e-01 9.64619219e-01 9.64619219e-01]\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]\n",
      "   ...\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]\n",
      "   [9.64583337e-01 9.64583337e-01 9.64583337e-01]]\n",
      "\n",
      "  [[9.61167276e-01 9.61167276e-01 9.61167276e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   ...\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]\n",
      "   [9.64705884e-01 9.64705884e-01 9.64705884e-01]]\n",
      "\n",
      "  [[9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.63526368e-01 9.63526368e-01 9.63526368e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   ...\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]\n",
      "   [9.62377429e-01 9.62377429e-01 9.62377429e-01]]]\n",
      "\n",
      "\n",
      " [[[9.64705884e-01 9.76470590e-01 9.96078432e-01]\n",
      "   [9.68627453e-01 9.84313726e-01 9.96078432e-01]\n",
      "   [9.70098019e-01 9.83333349e-01 9.96078432e-01]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[9.64705884e-01 9.76470590e-01 9.96078432e-01]\n",
      "   [9.68627453e-01 9.84313726e-01 9.96078432e-01]\n",
      "   [9.70098019e-01 9.83333349e-01 9.96078432e-01]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[9.64705884e-01 9.76470590e-01 9.96078432e-01]\n",
      "   [9.68627453e-01 9.80392158e-01 1.00000000e+00]\n",
      "   [9.68627453e-01 9.80882347e-01 9.99509811e-01]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[6.71057343e-01 6.63710177e-01 6.88357830e-01]\n",
      "   [7.29147494e-01 7.28795171e-01 7.59463072e-01]\n",
      "   [7.57925451e-01 7.57661223e-01 7.88285077e-01]\n",
      "   ...\n",
      "   [8.48749638e-01 8.34043741e-01 8.38945687e-01]\n",
      "   [7.07578897e-01 6.95814192e-01 6.76206350e-01]\n",
      "   [6.94199979e-01 6.86356843e-01 6.90278411e-01]]\n",
      "\n",
      "  [[5.00649154e-01 4.57138479e-01 4.72824752e-01]\n",
      "   [5.73305368e-01 5.43862998e-01 5.69322526e-01]\n",
      "   [6.52472019e-01 6.25729561e-01 6.50208712e-01]\n",
      "   ...\n",
      "   [8.22642863e-01 8.07936966e-01 8.12838912e-01]\n",
      "   [7.02450991e-01 6.90686285e-01 6.71078444e-01]\n",
      "   [7.14215696e-01 7.06372559e-01 7.10294127e-01]]\n",
      "\n",
      "  [[4.55284923e-01 4.54203039e-01 4.63714004e-01]\n",
      "   [5.23923874e-01 5.05786598e-01 5.28825819e-01]\n",
      "   [7.00109124e-01 6.90795422e-01 7.11383641e-01]\n",
      "   ...\n",
      "   [7.64770985e-01 7.50555277e-01 7.39280820e-01]\n",
      "   [7.12387025e-01 6.96700752e-01 6.84936047e-01]\n",
      "   [7.25980401e-01 7.18137264e-01 7.22058833e-01]]]\n",
      "\n",
      "\n",
      " ...\n",
      "\n",
      "\n",
      " [[[8.90196085e-01 8.50980401e-01 7.52941191e-01]\n",
      "   [8.91317785e-01 8.52102101e-01 7.54062891e-01]\n",
      "   [9.13736403e-01 8.82363856e-01 7.92167783e-01]\n",
      "   ...\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]]\n",
      "\n",
      "  [[8.94117653e-01 8.54901969e-01 7.56862760e-01]\n",
      "   [8.94117653e-01 8.54901969e-01 7.56862760e-01]\n",
      "   [8.98560047e-01 8.67187500e-01 7.76991427e-01]\n",
      "   ...\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]]\n",
      "\n",
      "  [[8.90196085e-01 8.47058833e-01 7.60784328e-01]\n",
      "   [8.94820273e-01 8.55604589e-01 7.57565379e-01]\n",
      "   [9.06779349e-01 8.75406802e-01 7.85210729e-01]\n",
      "   ...\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]\n",
      "   [9.88235295e-01 9.88235295e-01 9.56862748e-01]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[1.03446692e-01 3.67800258e-02 5.40747540e-03]\n",
      "   [1.16115198e-01 4.62928936e-02 7.07720593e-03]\n",
      "   [1.53329283e-01 4.70451787e-02 1.73950195e-03]\n",
      "   ...\n",
      "   [2.89605588e-01 1.13390274e-01 3.12449727e-02]\n",
      "   [4.19273943e-01 1.80673033e-01 9.81205981e-03]\n",
      "   [2.11106956e-01 6.02760464e-02 4.22943719e-02]]\n",
      "\n",
      "  [[1.01857021e-01 3.51903588e-02 3.81780881e-03]\n",
      "   [1.04610905e-01 3.47886011e-02 0.00000000e+00]\n",
      "   [3.27722639e-01 1.24632351e-01 9.46080871e-03]\n",
      "   ...\n",
      "   [1.07853428e-01 2.02298034e-02 5.16764296e-04]\n",
      "   [2.91826069e-01 1.01104259e-01 5.08626283e-04]\n",
      "   [4.13419724e-01 1.47478774e-01 3.27771939e-02]]\n",
      "\n",
      "  [[1.12718411e-01 3.42870392e-02 6.83605717e-03]\n",
      "   [1.12959556e-01 3.45281847e-02 0.00000000e+00]\n",
      "   [1.81287095e-01 5.82918040e-02 6.71841484e-03]\n",
      "   ...\n",
      "   [2.53291458e-01 7.74928704e-02 5.52369356e-02]\n",
      "   [9.27947387e-02 9.47816111e-03 0.00000000e+00]\n",
      "   [2.45066926e-01 6.17148019e-02 1.00708008e-02]]]\n",
      "\n",
      "\n",
      " [[[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [9.95157421e-01 9.95157421e-01 9.95157421e-01]\n",
      "   [9.41176474e-01 9.41176474e-01 9.41176474e-01]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]\n",
      "\n",
      "  [[1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   ...\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]\n",
      "   [1.00000000e+00 1.00000000e+00 1.00000000e+00]]]\n",
      "\n",
      "\n",
      " [[[9.95503962e-01 8.99617016e-01 6.44332111e-01]\n",
      "   [9.96315897e-01 9.02535260e-01 6.57674611e-01]\n",
      "   [9.89330590e-01 9.04105365e-01 6.52167559e-01]\n",
      "   ...\n",
      "   [9.89146769e-01 9.01049316e-01 6.53806686e-01]\n",
      "   [9.82590377e-01 9.01960790e-01 6.62408113e-01]\n",
      "   [9.87852335e-01 9.13388491e-01 6.76708043e-01]]\n",
      "\n",
      "  [[9.87852335e-01 9.06073809e-01 6.54901981e-01]\n",
      "   [9.90196049e-01 9.08417583e-01 6.70825660e-01]\n",
      "   [9.92064953e-01 8.99042606e-01 6.49931073e-01]\n",
      "   ...\n",
      "   [9.82490838e-01 8.98039222e-01 6.37346804e-01]\n",
      "   [9.79917288e-01 9.02634799e-01 6.67915106e-01]\n",
      "   [9.80200648e-01 9.04350519e-01 6.54947937e-01]]\n",
      "\n",
      "  [[9.93543208e-01 9.07268703e-01 6.61213219e-01]\n",
      "   [9.92731333e-01 9.03010130e-01 6.53278172e-01]\n",
      "   [9.90104139e-01 8.95986497e-01 6.48835778e-01]\n",
      "   ...\n",
      "   [9.83264387e-01 9.07935023e-01 6.52167559e-01]\n",
      "   [9.80729163e-01 8.99662971e-01 6.45572901e-01]\n",
      "   [9.80775118e-01 8.97656262e-01 6.46101415e-01]]\n",
      "\n",
      "  ...\n",
      "\n",
      "  [[7.89767146e-01 8.14682901e-01 8.27022076e-01]\n",
      "   [7.33134210e-01 7.71875024e-01 7.87461698e-01]\n",
      "   [8.18964481e-01 8.33831191e-01 8.37798715e-01]\n",
      "   ...\n",
      "   [2.27221206e-01 2.84405649e-01 2.65801162e-01]\n",
      "   [1.44584864e-01 1.43711701e-01 1.28500313e-01]\n",
      "   [3.06901038e-01 2.39422485e-01 2.31770828e-01]]\n",
      "\n",
      "  [[8.78048420e-01 8.91390920e-01 8.81395519e-01]\n",
      "   [7.68190861e-01 8.10891569e-01 8.08118880e-01]\n",
      "   [7.89690554e-01 8.17325354e-01 8.28086674e-01]\n",
      "   ...\n",
      "   [1.96262255e-01 2.37392768e-01 2.20795035e-01]\n",
      "   [3.01049322e-01 3.19845289e-01 2.80392170e-01]\n",
      "   [1.15831800e-01 1.14828430e-01 9.12990198e-02]]\n",
      "\n",
      "  [[8.72503042e-01 8.76233160e-01 8.73123467e-01]\n",
      "   [8.77382040e-01 8.94454658e-01 8.90295625e-01]\n",
      "   [8.92976403e-01 9.06701922e-01 8.93068314e-01]\n",
      "   ...\n",
      "   [2.74647683e-01 2.77428001e-01 2.52987146e-01]\n",
      "   [9.21331167e-01 9.39215660e-01 9.21331167e-01]\n",
      "   [6.36335790e-01 6.72441781e-01 6.63832724e-01]]]]\n",
      "[0 0 0 1 1 0 0 1 1 0 0 0 0 1 0 1 0 0 1 1 0 0 1 0 1 1 1 0 1 0 0 1 1 0 1 1 0\n",
      " 0 1 0]\n"
     ]
    }
   ],
   "source": [
    "batch[1].shape\n",
    "print(batch[0])\n",
    "print(batch[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 286,
   "id": "0dcaebcf-bbbe-453c-9ee3-2720cbe9effd",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.0"
      ]
     },
     "execution_count": 286,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "batch[0].max()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 287,
   "id": "2e60b703-d514-4022-b00e-c4233e2d003a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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",
      "text/plain": [
       "<Figure size 4000x4000 with 4 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax = plt.subplots(ncols=4, figsize=(40, 40))\n",
    "\n",
    "for idx, img in enumerate(batch[0][:4]):\n",
    "    ax[idx].imshow(img)\n",
    "    ax[idx].title.set_text(batch[1][idx])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 321,
   "id": "7ec859a6-051c-4d0c-b3a7-a94438e4ede1",
   "metadata": {},
   "outputs": [],
   "source": [
    "#building our model\n",
    "\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 322,
   "id": "2685047d-b867-4fd2-9981-651c6413fd47",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\u001b[0;31mSignature:\u001b[0m   \u001b[0mmodel\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
       "\u001b[0;31mType:\u001b[0m        Sequential\n",
       "\u001b[0;31mString form:\u001b[0m <Sequential name=sequential_7, built=False>\n",
       "\u001b[0;31mFile:\u001b[0m        ~/.local/lib/python3.12/site-packages/keras/src/models/sequential.py\n",
       "\u001b[0;31mSource:\u001b[0m     \n",
       "\u001b[0;34m@\u001b[0m\u001b[0mkeras_export\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"keras.Sequential\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"keras.models.Sequential\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;32mclass\u001b[0m \u001b[0mSequential\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mModel\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m\"\"\"`Sequential` groups a linear stack of layers into a `Model`.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    Examples:\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    ```python\u001b[0m\n",
       "\u001b[0;34m    model = keras.Sequential()\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.Input(shape=(16,)))\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(8))\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    # Note that you can also omit the initial `Input`.\u001b[0m\n",
       "\u001b[0;34m    # In that case the model doesn't have any weights until the first call\u001b[0m\n",
       "\u001b[0;34m    # to a training/evaluation method (since it isn't yet built):\u001b[0m\n",
       "\u001b[0;34m    model = keras.Sequential()\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(8))\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(4))\u001b[0m\n",
       "\u001b[0;34m    # model.weights not created yet\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    # Whereas if you specify an `Input`, the model gets built\u001b[0m\n",
       "\u001b[0;34m    # continuously as you are adding layers:\u001b[0m\n",
       "\u001b[0;34m    model = keras.Sequential()\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.Input(shape=(16,)))\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(8))\u001b[0m\n",
       "\u001b[0;34m    len(model.weights)  # Returns \"2\"\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    # When using the delayed-build pattern (no input shape specified), you can\u001b[0m\n",
       "\u001b[0;34m    # choose to manually build your model by calling\u001b[0m\n",
       "\u001b[0;34m    # `build(batch_input_shape)`:\u001b[0m\n",
       "\u001b[0;34m    model = keras.Sequential()\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(8))\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(4))\u001b[0m\n",
       "\u001b[0;34m    model.build((None, 16))\u001b[0m\n",
       "\u001b[0;34m    len(model.weights)  # Returns \"4\"\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m    # Note that when using the delayed-build pattern (no input shape specified),\u001b[0m\n",
       "\u001b[0;34m    # the model gets built the first time you call `fit`, `eval`, or `predict`,\u001b[0m\n",
       "\u001b[0;34m    # or the first time you call the model on some input data.\u001b[0m\n",
       "\u001b[0;34m    model = keras.Sequential()\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(8))\u001b[0m\n",
       "\u001b[0;34m    model.add(keras.layers.Dense(1))\u001b[0m\n",
       "\u001b[0;34m    model.compile(optimizer='sgd', loss='mse')\u001b[0m\n",
       "\u001b[0;34m    # This builds the model for the first time:\u001b[0m\n",
       "\u001b[0;34m    model.fit(x, y, batch_size=32, epochs=10)\u001b[0m\n",
       "\u001b[0;34m    ```\u001b[0m\n",
       "\u001b[0;34m    \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m__new__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcls\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mtyping\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcast\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mSequential\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__new__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcls\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrainable\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__init__\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtrainable\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtrainable\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mfor\u001b[0m \u001b[0mlayer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrebuild\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_maybe_rebuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrebuild\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"\"\"Adds a layer instance on top of the layer stack.\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m        Args:\u001b[0m\n",
       "\u001b[0;34m            layer: layer instance.\u001b[0m\n",
       "\u001b[0;34m        \"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Legacy case: if the first layer has an input_shape arg,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# use it to build an InputLayer.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"_input_shape_arg\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mInputLayer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_input_shape_arg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# If we are passed a Keras tensor created by keras.Input(), we\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# extract the input layer from its keras history and use that.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mhasattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"_keras_history\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0morigin_layer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_keras_history\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0morigin_layer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mlayer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0morigin_layer\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m\"Only instances of `keras.Layer` can be \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34madded to a Sequential model. Received: \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34m(of type \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_is_layer_name_unique\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m\"All layers added to a Sequential model \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34mshould have unique names. Name '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' is already \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m\"the name of a layer in this model. Update the `name` argument \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m\"to pass a unique name.\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mand\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has already been configured \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34mto use input shape \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch_shape\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m. You cannot \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34madd a different Input layer to it.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mrebuild\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_maybe_rebuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuilt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mpop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mrebuild\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m\"\"\"Removes the last layer in the model.\"\"\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mlayer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuilt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mrebuild\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_maybe_rebuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_maybe_rebuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuilt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0minput_shape\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch_shape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_lock_state\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Unlike other layers, Sequential is mutable after build.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mpass\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_obj_type\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0;34m\"Sequential\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mbuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minput_shape\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mtuple\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# Do not attempt to build if the model does not have a single\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# input tensor.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0minput_shape\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mint\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0minput_shape\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# Do not attempt to build if the model does not have a single\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# input tensor.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m cannot be built because it has \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m\"no layers. Call `model.add(layer)`.\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch_shape\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0minput_shape\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has already been \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;34m\"configured to use input shape \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;34mf\"\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch_shape\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m. You cannot build it \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;34mf\"\u001b[0m\u001b[0;34mwith input_shape \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mdtype\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcompute_dtype\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mInputLayer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbatch_shape\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mdtype\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m]\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Build functional model\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0minputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mlayer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mexcept\u001b[0m \u001b[0mNotImplementedError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;31m# Can happen if shape inference is not implemented.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;31m# TODO: consider reverting inbound nodes on layers processed.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mreturn\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mexcept\u001b[0m \u001b[0mTypeError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0msignature\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0minspect\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msignature\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcall\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mpositional_args\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0mparam\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;32mfor\u001b[0m \u001b[0mparam\u001b[0m \u001b[0;32min\u001b[0m \u001b[0msignature\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mparameters\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mvalues\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;32mif\u001b[0m \u001b[0mparam\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdefault\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0minspect\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mParameter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mempty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpositional_args\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m!=\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                        \u001b[0;34m\"Layers added to a Sequential model \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                        \u001b[0;34m\"can only have a single positional argument, \"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                        \u001b[0;34mf\"\u001b[0m\u001b[0;34mthe input tensor. Layer \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__class__\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__name__\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m \u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                        \u001b[0;34mf\"\u001b[0m\u001b[0;34mhas multiple positional arguments: \u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mpositional_args\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mraise\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0moutputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mFunctional\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0moutputs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuilt\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mcall\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcall\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtraining\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmask\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Fallback: Just apply the layer sequence.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# This typically happens if `inputs` is a nested struct.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mlayer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlayers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# During each iteration, `inputs` are the inputs to `layer`, and\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# `outputs` are the outputs of `layer` applied to `inputs`. At the\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# end of each iteration `inputs` is set to `outputs` to prepare for\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# the next layer.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mkwargs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_call_has_mask_arg\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mkwargs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"mask\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_call_has_training_arg\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mtraining\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mkwargs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"training\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0moutputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0minputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mdef\u001b[0m \u001b[0m_get_mask_from_keras_tensor\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkt\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mreturn\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mkt\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"_keras_mask\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmask\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtree\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmap_structure\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_get_mask_from_keras_tensor\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Historically, `sequential.layers` only returns layers that were added\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# via `add`, and omits the auto-generated `InputLayer` that comes at the\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# bottom of the stack.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mlayers\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mlayers\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mcompute_output_spec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcompute_output_spec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtraining\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmask\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mmask\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Direct application\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mlayer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlayers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0moutputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcompute_output_spec\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0minputs\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtraining\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mtraining\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34m)\u001b[0m  \u001b[0;31m# Ignore mask\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0minputs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0minput_shape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minput_shape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has no defined input shape yet.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0moutput_shape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutput_shape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has no defined output shape yet.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0minputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has no defined inputs yet.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0moutputs\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0moutputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;34mf\"\u001b[0m\u001b[0;34mSequential model '\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m' has no defined outputs yet.\u001b[0m\u001b[0;34m\"\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0minput_dtype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# Sequential.__call__ will try to convert its inputs\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;31m# to the dtype expected by its input layer, if any.\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mlayers\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mlayers\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mInputLayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mreturn\u001b[0m \u001b[0mlayers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minput_dtype\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0m_is_layer_name_unique\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mref_layer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mref_layer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mref_layer\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mlayer\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;32mreturn\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mget_config\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mserialize_fn\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mserialization_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mserialize_keras_object\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mglobal_state\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_global_attribute\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"use_legacy_config\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mFalse\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# Legacy format serialization used for H5 and SavedModel formats\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mserialize_fn\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mlegacy_serialization\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mserialize_keras_object\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mlayer_configs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mlayer\u001b[0m \u001b[0;32min\u001b[0m \u001b[0msuper\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlayers\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# `super().layers` include the InputLayer if available (it is\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;31m# filtered out of `self.layers`).\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mlayer_configs\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mserialize_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mconfig\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mModel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_config\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mconfig\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"name\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mconfig\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"layers\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcopy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeepcopy\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer_configs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mconfig\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"build_input_shape\"\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_layers\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbatch_shape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;34m@\u001b[0m\u001b[0mclassmethod\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m    \u001b[0;32mdef\u001b[0m \u001b[0mfrom_config\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mcls\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcustom_objects\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;32mNone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;34m\"name\"\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"name\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mbuild_input_shape\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"build_input_shape\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mlayer_configs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"layers\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mname\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mlayer_configs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mconfig\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0mmodel\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcls\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mname\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mfor\u001b[0m \u001b[0mlayer_config\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mlayer_configs\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mif\u001b[0m \u001b[0;34m\"module\"\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mlayer_config\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;31m# Legacy format deserialization (no \"module\" key)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;31m# used for H5 and SavedModel formats\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mlayer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0msaving_utils\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmodel_from_config\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0mlayer_config\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0mcustom_objects\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mcustom_objects\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0mlayer\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mserialization_lib\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeserialize_keras_object\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0mlayer_config\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                    \u001b[0mcustom_objects\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mcustom_objects\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m                \u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlayer\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mif\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mnot\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_functional\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mand\u001b[0m \u001b[0mbuild_input_shape\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0;32mand\u001b[0m \u001b[0misinstance\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbuild_input_shape\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mtuple\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m            \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbuild\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mbuild_input_shape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\n",
       "\u001b[0;34m\u001b[0m        \u001b[0;32mreturn\u001b[0m \u001b[0mmodel\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "model = Sequential()\n",
    "model??"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 323,
   "id": "270d35b9-c20b-486a-90cf-8b4239c29df2",
   "metadata": {},
   "outputs": [],
   "source": [
    "#adding layers to our model\n",
    "\n",
    "model.add(Conv2D(16, (3, 3), 1, activation='relu', input_shape=(256, 256, 3)))\n",
    "model.add(MaxPooling2D())\n",
    "\n",
    "model.add(Conv2D(16*2, (3, 3), 1, activation='relu'))\n",
    "model.add(MaxPooling2D())\n",
    "\n",
    " model.add(Conv2D(16, (3, 3), 1, activation='relu'))\n",
    "model.add(MaxPooling2D())\n",
    "\n",
    "model.add(Flatten())\n",
    "\n",
    "model.add(Dense(256, activation='relu'))\n",
    "model.add(Dense(1, activation='sigmoid'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 324,
   "id": "6c1222a5-40c2-42dc-ba1b-556d3192820f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#compiling our model\n",
    "\n",
    "model.compile('adam', loss=tf.losses.BinaryCrossentropy(), metrics=['accuracy'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 325,
   "id": "48d8003c-c4e3-40b0-a461-6f20e31aa440",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\">Model: \"sequential_7\"</span>\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1mModel: \"sequential_7\"\u001b[0m\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n",
       "┃<span style=\"font-weight: bold\"> Layer (type)                    </span>┃<span style=\"font-weight: bold\"> Output Shape           </span>┃<span style=\"font-weight: bold\">       Param # </span>┃\n",
       "┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n",
       "│ conv2d_19 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv2D</span>)              │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">254</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">254</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)   │           <span style=\"color: #00af00; text-decoration-color: #00af00\">448</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_15 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling2D</span>) │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">127</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">127</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)   │             <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ conv2d_20 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv2D</span>)              │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">125</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">125</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)   │         <span style=\"color: #00af00; text-decoration-color: #00af00\">4,640</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_16 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling2D</span>) │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">62</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">62</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)     │             <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ conv2d_21 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv2D</span>)              │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">60</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">60</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)     │         <span style=\"color: #00af00; text-decoration-color: #00af00\">4,624</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_17 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling2D</span>) │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">30</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">30</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)     │             <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ flatten_5 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Flatten</span>)             │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">14400</span>)          │             <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ dense_10 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Dense</span>)                │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">256</span>)            │     <span style=\"color: #00af00; text-decoration-color: #00af00\">3,686,656</span> │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ dense_11 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Dense</span>)                │ (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">1</span>)              │           <span style=\"color: #00af00; text-decoration-color: #00af00\">257</span> │\n",
       "└─────────────────────────────────┴────────────────────────┴───────────────┘\n",
       "</pre>\n"
      ],
      "text/plain": [
       "┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n",
       "┃\u001b[1m \u001b[0m\u001b[1mLayer (type)                   \u001b[0m\u001b[1m \u001b[0m┃\u001b[1m \u001b[0m\u001b[1mOutput Shape          \u001b[0m\u001b[1m \u001b[0m┃\u001b[1m \u001b[0m\u001b[1m      Param #\u001b[0m\u001b[1m \u001b[0m┃\n",
       "┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n",
       "│ conv2d_19 (\u001b[38;5;33mConv2D\u001b[0m)              │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m254\u001b[0m, \u001b[38;5;34m254\u001b[0m, \u001b[38;5;34m16\u001b[0m)   │           \u001b[38;5;34m448\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_15 (\u001b[38;5;33mMaxPooling2D\u001b[0m) │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m127\u001b[0m, \u001b[38;5;34m127\u001b[0m, \u001b[38;5;34m16\u001b[0m)   │             \u001b[38;5;34m0\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ conv2d_20 (\u001b[38;5;33mConv2D\u001b[0m)              │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m125\u001b[0m, \u001b[38;5;34m125\u001b[0m, \u001b[38;5;34m32\u001b[0m)   │         \u001b[38;5;34m4,640\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_16 (\u001b[38;5;33mMaxPooling2D\u001b[0m) │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m62\u001b[0m, \u001b[38;5;34m62\u001b[0m, \u001b[38;5;34m32\u001b[0m)     │             \u001b[38;5;34m0\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ conv2d_21 (\u001b[38;5;33mConv2D\u001b[0m)              │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m60\u001b[0m, \u001b[38;5;34m60\u001b[0m, \u001b[38;5;34m16\u001b[0m)     │         \u001b[38;5;34m4,624\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ max_pooling2d_17 (\u001b[38;5;33mMaxPooling2D\u001b[0m) │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m30\u001b[0m, \u001b[38;5;34m30\u001b[0m, \u001b[38;5;34m16\u001b[0m)     │             \u001b[38;5;34m0\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ flatten_5 (\u001b[38;5;33mFlatten\u001b[0m)             │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m14400\u001b[0m)          │             \u001b[38;5;34m0\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ dense_10 (\u001b[38;5;33mDense\u001b[0m)                │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m256\u001b[0m)            │     \u001b[38;5;34m3,686,656\u001b[0m │\n",
       "├─────────────────────────────────┼────────────────────────┼───────────────┤\n",
       "│ dense_11 (\u001b[38;5;33mDense\u001b[0m)                │ (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m1\u001b[0m)              │           \u001b[38;5;34m257\u001b[0m │\n",
       "└─────────────────────────────────┴────────────────────────┴───────────────┘\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Total params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">3,696,625</span> (14.10 MB)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Total params: \u001b[0m\u001b[38;5;34m3,696,625\u001b[0m (14.10 MB)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Trainable params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">3,696,625</span> (14.10 MB)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Trainable params: \u001b[0m\u001b[38;5;34m3,696,625\u001b[0m (14.10 MB)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Non-trainable params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> (0.00 B)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Non-trainable params: \u001b[0m\u001b[38;5;34m0\u001b[0m (0.00 B)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "#summarizing the model compilation\n",
    "\n",
    "model.summary()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 326,
   "id": "c449b0e6-0db9-4ab0-aa93-121a875d3d60",
   "metadata": {},
   "outputs": [],
   "source": [
    "#training our model\n",
    "\n",
    "logdir = 'logs'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 331,
   "id": "3b64cdf1-218e-4e7d-a3b7-127e5fa29924",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(<_TakeDataset element_spec=(TensorSpec(shape=(None, 128, 128, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None,), dtype=tf.int32, name=None))>,\n",
       " <_TakeDataset element_spec=(TensorSpec(shape=(None, 128, 128, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None,), dtype=tf.int32, name=None))>,\n",
       " <keras.src.callbacks.tensorboard.TensorBoard at 0x7fbdda16bcb0>)"
      ]
     },
     "execution_count": 331,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=logdir)\n",
    "training_data, valid_data, tensorboard_callback"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 336,
   "id": "a83032de-52b3-42cb-bd80-073031f9f692",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/20\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "Exception encountered when calling Sequential.call().\n\n\u001b[1mInput 0 of layer \"dense_10\" is incompatible with the layer: expected axis -1 of input shape to have value 14400, but received input with shape (None, 3136)\u001b[0m\n\nArguments received by Sequential.call():\n  • inputs=tf.Tensor(shape=(None, 128, 128, 3), dtype=float32)\n  • training=True\n  • mask=None",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[336], line 1\u001b[0m\n\u001b[0;32m----> 1\u001b[0m history \u001b[38;5;241m=\u001b[39m \u001b[43mmodel\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfit\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtraining_data\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mepochs\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m20\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mvalidation_data\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mvalid_data\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mcallbacks\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43m[\u001b[49m\u001b[43mtensorboard_callback\u001b[49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[0;32m~/.local/lib/python3.12/site-packages/keras/src/utils/traceback_utils.py:122\u001b[0m, in \u001b[0;36mfilter_traceback.<locals>.error_handler\u001b[0;34m(*args, **kwargs)\u001b[0m\n\u001b[1;32m    119\u001b[0m     filtered_tb \u001b[38;5;241m=\u001b[39m _process_traceback_frames(e\u001b[38;5;241m.\u001b[39m__traceback__)\n\u001b[1;32m    120\u001b[0m     \u001b[38;5;66;03m# To get the full stack trace, call:\u001b[39;00m\n\u001b[1;32m    121\u001b[0m     \u001b[38;5;66;03m# `keras.config.disable_traceback_filtering()`\u001b[39;00m\n\u001b[0;32m--> 122\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m e\u001b[38;5;241m.\u001b[39mwith_traceback(filtered_tb) \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[1;32m    123\u001b[0m \u001b[38;5;28;01mfinally\u001b[39;00m:\n\u001b[1;32m    124\u001b[0m     \u001b[38;5;28;01mdel\u001b[39;00m filtered_tb\n",
      "File \u001b[0;32m~/.local/lib/python3.12/site-packages/keras/src/layers/input_spec.py:227\u001b[0m, in \u001b[0;36massert_input_compatibility\u001b[0;34m(input_spec, inputs, layer_name)\u001b[0m\n\u001b[1;32m    222\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m axis, value \u001b[38;5;129;01min\u001b[39;00m spec\u001b[38;5;241m.\u001b[39maxes\u001b[38;5;241m.\u001b[39mitems():\n\u001b[1;32m    223\u001b[0m         \u001b[38;5;28;01mif\u001b[39;00m value \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m \u001b[38;5;129;01mand\u001b[39;00m shape[axis] \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m {\n\u001b[1;32m    224\u001b[0m             value,\n\u001b[1;32m    225\u001b[0m             \u001b[38;5;28;01mNone\u001b[39;00m,\n\u001b[1;32m    226\u001b[0m         }:\n\u001b[0;32m--> 227\u001b[0m             \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\n\u001b[1;32m    228\u001b[0m                 \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mInput \u001b[39m\u001b[38;5;132;01m{\u001b[39;00minput_index\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m of layer \u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mlayer_name\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m is \u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[1;32m    229\u001b[0m                 \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mincompatible with the layer: expected axis \u001b[39m\u001b[38;5;132;01m{\u001b[39;00maxis\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    230\u001b[0m                 \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mof input shape to have value \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mvalue\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m, \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    231\u001b[0m                 \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mbut received input with \u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    232\u001b[0m                 \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mshape \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mshape\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m\n\u001b[1;32m    233\u001b[0m             )\n\u001b[1;32m    234\u001b[0m \u001b[38;5;66;03m# Check shape.\u001b[39;00m\n\u001b[1;32m    235\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m spec\u001b[38;5;241m.\u001b[39mshape \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
      "\u001b[0;31mValueError\u001b[0m: Exception encountered when calling Sequential.call().\n\n\u001b[1mInput 0 of layer \"dense_10\" is incompatible with the layer: expected axis -1 of input shape to have value 14400, but received input with shape (None, 3136)\u001b[0m\n\nArguments received by Sequential.call():\n  • inputs=tf.Tensor(shape=(None, 128, 128, 3), dtype=float32)\n  • training=True\n  • mask=None"
     ]
    }
   ],
   "source": [
    "history = model.fit(training_data, epochs=20, validation_data=valid_data, callbacks=[tensorboard_callback])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ba0ff63-6daa-4340-a226-f6f3c19be6c8",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8637619f-66cc-48c1-8936-0644dd2f87c3",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4131462a-3ac6-44e3-b962-fd2a7bed0713",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f78c3f6a-68b2-46cb-af98-b2f296fdd8fd",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8614048b-9340-4f5d-9f20-af1c9e175bb6",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
